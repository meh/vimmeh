" VIM 7.0 omni-completion for Haskell
" Version:	2007-03-04 21:48
" Author:	Stephan Walter <stephan@walter.name>
"
" Usage:	put file in ~/.vim/plugin/
"		:set omnifunc=haskellcomplete#CompleteHaskell
"		press <C-X><C-O> to complete
"
" this is very limited stuff, suggestions welcome!
" currently implemented:
"	some Prelude functions and types
"	complete functions imported from base libs (but list has yet to be written)
"	if line above is type definition, complete function name
"
" Copyright (c) 2007, Stephan Walter {{{
" All rights reserved.
"
"Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
"	* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
"	* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
"	* Neither name of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
"
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
" }}}

function! haskellcomplete#CompleteHaskell(findstart, base)
	if a:findstart
		" find beginning of identifier
		let line = getline('.')
		let b:start = col('.') - 1
		let compl_begin = col('.') - 2
		while b:start >= 0 && line[b:start - 1] =~ '\w'
			let b:start -= 1
		endwhile
		return b:start
	endif

	let row = line('.')

	if b:start == 0
		" special handing for first column of line
		if row == 1
			" we're at first character of file,
			" probably we want to write the module def
			return ['module ']
		elseif getline(row-1) =~ '^\h\w*\s*::'
			" line above is a type def, return function name
			return [matchlist(getline(row-1),'^\(\h\w*\)\s*::')[1].' ']
		endif
	endif

	if a:base == ''
		" if nothing was typed, don't offer completions
		return []
	endif

	let all_values = {}
	let res = []
	if !exists('g:haskell_modules')
		call haskellcomplete#LoadData()
	endif

	call extend(all_values, g:haskell_modules)
	call extend(all_values, g:haskell_lib_functions['Prelude'])
	call extend(all_values, g:haskell_lib_types['Prelude'])

	" add function names for imported modules
	" TODO: look for modules not in base libraries
	for l in getline(1, 50)	"only look for imports in the first 50 lines
		if l =~# '^import\s'
			let m = matchlist(l, '^import\s\+\(\u[A-Za-z\.]*\)')[1]
			if has_key(g:haskell_lib_functions, m)
				call extend(all_values, g:haskell_lib_functions[m])
			endif
			if has_key(g:haskell_lib_types, m)
				call extend(all_values, g:haskell_lib_types[m])
			endif
		endif
	endfor

	" add functions from file which have typedefs
	let typedefs = filter(getline(1,'$'), 'v:val =~ "^\\h\\w*\\s*::"')
	for t in typedefs
		let n = matchlist(t, '^\(\h\w*\)\s*::\s*\(.*\)\s*$')
		call extend(all_values, {n[1]:n[2]})
	endfor

	" TODO: add other symbols defined in current file (like pressing <C-N>)
	" TODO: handle `infix` and operators

	for o in sort(keys(all_values))
		if o =~# '^'.a:base
			call add(res, o)
		endif
	endfor

	let final_list = []
	for i in res
		if all_values[i] == ''
			call add(final_list, i)
		else
			call add(final_list, {'word':i, 'menu':':: '.all_values[i]})
		endif
	endfor
	return final_list
endfunction

function! haskellcomplete#LoadData()
	" TODO: fill in lots of data
	let g:haskell_modules = {
		\'Array':'',
		\'Bits':'',
		\'Char':'',
		\'Control.Concurrent':'',
		\'Control.Concurrent.STM':'',
		\'Control.Exception':'',
		\'Control.Monad':'',
		\'IO':'',
		\'List':'',
		\'Maybe':'',
		\'Monad':'',
		\'Numeric':'',
		\'Network':'',
		\'Prelude':'',
		\'System':'',
		\'System.Directory':'',
		\'System.Environment':'',
		\'System.IO':'',
		\'System.Time':'',
		\'Time':'',
	\}
	"{{{ haskell_lib_functions
	let g:haskell_lib_functions = {
		\'Array':{
			\"accum":"Ix a => (b -> c -> b) -> Array a b -> [(a,c)] -> Array a b",
			\"accumArray":"Ix a => (b -> c -> b) -> b -> (a,a) -> [(a,c)] -> Array a b",
			\"array":"Ix a => (a,a) -> [(a,b)] -> Array a b",
			\"assocs":"Ix a => Array a b -> [(a,b)]",
			\"bounds":"Ix a => Array a b -> (a,a)",
			\"elems":"Ix a => Array a b -> [b]",
			\"indices":"Ix a => Array a b -> [a]",
			\"ixmap":"(Ix a, Ix b) => (a,a) -> (a -> b) -> Array b c -> Array a c",
			\"listArray":"Ix a => (a,a) -> [b] -> Array a b",
		\},
		\'CPUTime':{
			\"cpuTimePrecision":"Integer",
			\"getCPUTime":"IO Integer",
		\},
		\'Char':{
			\"chr":"Int -> Char",
			\"digitToInt":"Char -> Int",
			\"intToDigit":"Int -> Char",
			\"isAlpha":"Char -> Bool",
			\"isAlphaNum":"Char -> Bool",
			\"isAscii":"Char -> Bool",
			\"isControl":"Char -> Bool",
			\"isDigit":"Char -> Bool",
			\"isHexDigit":"Char -> Bool",
			\"isLatin1":"a -> Bool",
			\"isLower":"Char -> Bool",
			\"isOctDigit":"Char -> Bool",
			\"isPrint":"Char -> Bool",
			\"isSpace":"Char -> Bool",
			\"isUpper":"Char -> Bool",
			\"lexLitChar":"ReadS String",
			\"ord":"Char -> Int",
			\"readLitChar":"ReadS Char",
			\"showLitChar":"Char -> ShowS",
			\"toLower":"Char -> Char",
			\"toUpper":"Char -> Char",
		\},
		\'Complex':{
			\"cis":"RealFloat a => a -> Complex a",
			\"conjugate":"RealFloat a => Complex a -> Complex a",
			\"imagPart":"RealFloat a => Complex a -> a",
			\"magnitude":"RealFloat a => Complex a -> a",
			\"mkPolar":"RealFloat a => a -> a -> Complex a",
			\"phase":"RealFloat a => Complex a -> a",
			\"polar":"RealFloat a => Complex a -> (a,a)",
			\"realPart":"RealFloat a => Complex a -> a",
		\},
		\'Control.Arrow':{
			\"app":"ArrowApply a => a (a b c,b) c",
			\"arr":"Arrow a => (b -> c) -> a b c",
			\"first":"Arrow a => a b c -> a (b,d) (c,d)",
			\"left":"ArrowChoice a => a b c -> a (Either b d) (Either c d)",
			\"leftApp":"ArrowApply a => a b c -> a (Either b d) (Either c d)",
			\"loop":"ArrowLoop a => a (b,d) (c,d) -> a b c",
			\"pure":"Arrow a => (b -> c) -> a b c",
			\"returnA":"Arrow a => a b b",
			\"right":"ArrowChoice a => a b c -> a (Either d b) (Either d c)",
			\"runKleisli":"Kleisli m a b -> a -> m b",
			\"second":"Arrow a => a b c -> a (d,b) (d,c)",
			\"zeroArrow":"ArrowZero a => a b c",
		\},
		\'Control.Concurrent':{
			\"forkIO":"IO () -> IO ThreadId",
			\"forkOS":"IO () -> IO ThreadId",
			\"isCurrentThreadBound":"IO Bool",
			\"killThread":"ThreadId -> IO ()",
			\"mergeIO":"[a] -> [a] -> IO [a]",
			\"myThreadId":"IO ThreadId",
			\"nmergeIO":"[[a]] -> IO [a]",
			\"rtsSupportsBoundThreads":"Bool",
			\"runInBoundThread":"IO a -> IO a",
			\"runInUnboundThread":"IO a -> IO a",
			\"threadDelay":"Int -> IO ()",
			\"threadWaitRead":"Fd -> IO ()",
			\"threadWaitWrite":"Fd -> IO ()",
			\"throwTo":"ThreadId -> Exception -> IO ()",
			\"yield":"IO ()",
		\},
		\'Control.Concurrent.Chan':{
			\"dupChan":"Chan a -> IO (Chan a)",
			\"getChanContents":"Chan a -> IO [a]",
			\"isEmptyChan":"Chan a -> IO Bool",
			\"newChan":"IO (Chan a)",
			\"readChan":"Chan a -> IO a",
			\"unGetChan":"Chan a -> a -> IO ()",
			\"writeChan":"Chan a -> a -> IO ()",
			\"writeList2Chan":"Chan a -> [a] -> IO ()",
		\},
		\'Control.Concurrent.MVar':{
			\"modifyMVar":"MVar a -> (a -> IO (a, b)) -> IO b",
			\"modifyMVar_":"MVar a -> (a -> IO a) -> IO ()",
			\"readMVar":"MVar a -> IO a",
			\"swapMVar":"MVar a -> a -> IO a",
			\"withMVar":"MVar a -> (a -> IO b) -> IO b",
		\},
		\'Control.Concurrent.QSem':{
			\"newQSem":"Int -> IO QSem",
			\"signalQSem":"QSem -> IO ()",
			\"waitQSem":"QSem -> IO ()",
		\},
		\'Control.Concurrent.QSemN':{
			\"newQSemN":"Int -> IO QSemN",
			\"signalQSemN":"QSemN -> Int -> IO ()",
			\"waitQSemN":"QSemN -> Int -> IO ()",
		\},
		\'Control.Concurrent.STM':{
			\"check":"Bool -> STM a",
		\},
		\'Control.Concurrent.STM.TChan':{
			\"dupTChan":"TChan a -> STM (TChan a)",
			\"isEmptyTChan":"TChan a -> STM Bool",
			\"newTChan":"STM (TChan a)",
			\"readTChan":"TChan a -> STM a",
			\"unGetTChan":"TChan a -> a -> STM ()",
			\"writeTChan":"TChan a -> a -> STM ()",
		\},
		\'Control.Concurrent.STM.TMVar':{
			\"isEmptyTMVar":"TMVar a -> STM Bool",
			\"newEmptyTMVar":"STM (TMVar a)",
			\"newTMVar":"a -> STM (TMVar a)",
			\"putTMVar":"TMVar a -> a -> STM ()",
			\"readTMVar":"TMVar a -> STM a",
			\"swapTMVar":"TMVar a -> a -> STM a",
			\"takeTMVar":"TMVar a -> STM a",
			\"tryPutTMVar":"TMVar a -> a -> STM Bool",
			\"tryTakeTMVar":"TMVar a -> STM (Maybe a)",
		\},
		\'Control.Concurrent.STM.TVar':{
		\},
		\'Control.Concurrent.SampleVar':{
			\"emptySampleVar":"SampleVar a -> IO ()",
			\"isEmptySampleVar":"SampleVar a -> IO Bool",
			\"newEmptySampleVar":"IO (SampleVar a)",
			\"newSampleVar":"a -> IO (SampleVar a)",
			\"readSampleVar":"SampleVar a -> IO a",
			\"writeSampleVar":"SampleVar a -> a -> IO ()",
		\},
		\'Control.Exception':{
			\"arithExceptions":"Exception -> Maybe ArithException",
			\"assert":"Bool -> a -> a",
			\"assertions":"Exception -> Maybe String",
			\"asyncExceptions":"Exception -> Maybe AsyncException",
			\"block":"IO a -> IO a",
			\"bracket_":"IO a -> IO b -> IO c -> IO c",
			\"catch":"IO a -> (Exception -> IO a) -> IO a",
			\"catchDyn":"Typeable exception => IO a -> (exception -> IO a) -> IO a",
			\"catchJust":"(Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a",
			\"dynExceptions":"Exception -> Maybe Dynamic",
			\"errorCalls":"Exception -> Maybe String",
			\"evaluate":"a -> IO a",
			\"finally":"IO a -> IO b -> IO a",
			\"getUncaughtExceptionHandler":"IO (Exception -> IO ())",
			\"handle":"(Exception -> IO a) -> IO a -> IO a",
			\"handleJust":"(Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a",
			\"ioErrors":"Exception -> Maybe IOError",
			\"mapException":"(Exception -> Exception) -> a -> a",
			\"setUncaughtExceptionHandler":"(Exception -> IO ()) -> IO ()",
			\"throw":"Exception -> a",
			\"throwDyn":"Typeable exception => exception -> b",
			\"throwDynTo":"Typeable exception => ThreadId -> exception -> IO ()",
			\"throwIO":"Exception -> IO a",
			\"try":"IO a -> IO (Either Exception a)",
			\"tryJust":"(Exception -> Maybe b) -> IO a -> IO (Either b a)",
			\"unblock":"IO a -> IO a",
			\"userErrors":"Exception -> Maybe String",
		\},
		\'Control.Monad':{
			\"ap":"Monad m => m (a -> b) -> m a -> m b",
			\"filterM":"Monad m => (a -> m Bool) -> [a] -> m [a]",
			\"foldM":"Monad m => (a -> b -> m a) -> a -> [b] -> m a",
			\"foldM_":"Monad m => (a -> b -> m a) -> a -> [b] -> m ()",
			\"guard":"MonadPlus m => Bool -> m ()",
			\"join":"Monad m => m (m a) -> m a",
			\"liftM":"Monad m => (a1 -> r) -> m a1 -> m r",
			\"liftM2":"Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r",
			\"liftM3":"Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r",
			\"liftM4":"Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r",
			\"liftM5":"Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r",
			\"mapAndUnzipM":"Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])",
			\"mplus":"MonadPlus m => m a -> m a -> m a",
			\"msum":"MonadPlus m => [m a] -> m a",
			\"mzero":"MonadPlus m => m a",
			\"replicateM":"Monad m => Int -> m a -> m [a]",
			\"replicateM_":"Monad m => Int -> m a -> m ()",
			\"unless":"Monad m => Bool -> m () -> m ()",
			\"when":"Monad m => Bool -> m () -> m ()",
			\"zipWithM":"Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]",
			\"zipWithM_":"Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()",
		\},
		\'Control.Monad.Cont':{
			\"callCC":"MonadCont m => ((a -> m b) -> m a) -> m a",
			\"mapCont":"(r -> r) -> Cont r a -> Cont r a",
			\"mapContT":"(m r -> m r) -> ContT r m a -> ContT r m a",
			\"runCont":"Cont r a -> ((a -> r) -> r)",
			\"runContT":"ContT r m a -> ((a -> m r) -> m r)",
			\"withCont":"((b -> r) -> a -> r) -> Cont r a -> Cont r b",
			\"withContT":"((b -> m r) -> a -> m r) -> ContT r m a -> ContT r m b",
		\},
		\'Control.Monad.Error':{
			\"catchError":"MonadError e m => m a -> (e -> m a) -> m a",
			\"mapErrorT":"(m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b",
			\"noMsg":"Error a => a",
			\"runErrorT":"ErrorT e m a -> (m (Either e a))",
			\"strMsg":"Error a => String -> a",
			\"throwError":"MonadError e m => e -> m a",
		\},
		\'Control.Monad.Fix':{
			\"fix":"(a -> a) -> a",
			\"mfix":"MonadFix m => (a -> m a) -> m a",
		\},
		\'Control.Monad.Identity':{
			\"runIdentity":"Identity a -> a",
		\},
		\'Control.Monad.List':{
			\"mapListT":"(m [a] -> n [b]) -> ListT m a -> ListT n b",
			\"runListT":"ListT m a -> m [a]",
		\},
		\'Control.Monad.RWS':{
			\"evalRWS":"RWS r w s a -> r -> s -> (a, w)",
			\"evalRWST":"Monad m => RWST r w s m a -> r -> s -> m (a, w)",
			\"execRWS":"RWS r w s a -> r -> s -> (s, w)",
			\"execRWST":"Monad m => RWST r w s m a -> r -> s -> m (s, w)",
			\"mapRWS":"((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b",
			\"mapRWST":"(m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b",
			\"runRWS":"RWS r w s a -> (r -> s -> (a,s,w))",
			\"runRWST":"RWST r w s m a -> (r -> s -> m (a,s,w))",
			\"withRWS":"(r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a",
			\"withRWST":"(r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a",
		\},
		\'Control.Monad.Reader':{
			\"ask":"MonadReader r m => m r",
			\"asks":"MonadReader r m => (r -> a) -> m a",
			\"local":"MonadReader r m => (r -> r) -> m a -> m a",
			\"mapReader":"(a -> b) -> Reader r a -> Reader r b",
			\"mapReaderT":"(m a -> n b) -> ReaderT w m a -> ReaderT w n b",
			\"runReader":"Reader r a -> r -> a",
			\"runReaderT":"ReaderT r m a -> r -> m a",
			\"withReader":"(r' -> r) -> Reader r a -> Reader r' a",
			\"withReaderT":"(r' -> r) -> ReaderT r m a -> ReaderT r' m a",
		\},
		\'Control.Monad.ST':{
			\"fixST":"(a -> ST s a) -> ST s a",
			\"runST":"(ST s a) -> a",
			\"stToIO":"ST RealWorld a -> IO a",
			\"unsafeIOToST":"IO a -> ST s a",
			\"unsafeInterleaveST":"ST s a -> ST s a",
		\},
		\'Control.Monad.ST.Lazy':{
			\"lazyToStrictST":"ST s a -> ST s a",
			\"strictToLazyST":"ST s a -> ST s a",
		\},
		\'Control.Monad.State':{
			\"evalState":"State s a -> s -> a",
			\"evalStateT":"Monad m => StateT s m a -> s -> m a",
			\"execState":"State s a -> s -> s",
			\"execStateT":"Monad m => StateT s m a -> s -> m s",
			\"get":"MonadState s m => m s",
			\"gets":"MonadState s m => (s -> a) -> m a",
			\"mapState":"((a, s) -> (b, s)) -> State s a -> State s b",
			\"mapStateT":"(m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b",
			\"modify":"MonadState s m => (s -> s) -> m ()",
			\"put":"MonadState s m => s -> m ()",
			\"runState":"State s a -> (s -> (a,s))",
			\"runStateT":"StateT s m a -> (s -> m (a,s))",
			\"withState":"(s -> s) -> State s a -> State s a",
			\"withStateT":"(s -> s) -> StateT s m a -> StateT s m a",
		\},
		\'Control.Monad.Trans':{
			\"lift":"(MonadTrans t, Monad m) => m a -> t m a",
			\"liftIO":"MonadIO m => IO a -> m a",
		\},
		\'Control.Monad.Writer':{
			\"censor":"MonadWriter w m => (w -> w) -> m a -> m a",
			\"execWriter":"Writer w a -> w",
			\"execWriterT":"Monad m => WriterT w m a -> m w",
			\"listen":"MonadWriter w m => m a -> m (a,w)",
			\"listens":"MonadWriter w m => (w -> b) -> m a -> m (a, b)",
			\"mapWriter":"((a, w) -> (b, w')) -> Writer w a -> Writer w' b",
			\"mapWriterT":"(m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b",
			\"pass":"MonadWriter w m => m (a,w -> w) -> m a",
			\"runWriter":"Writer w a -> a,w",
			\"runWriterT":"WriterT w m a -> (m (a,w))",
			\"tell":"MonadWriter w m => w -> m ()",
		\},
		\'Control.Parallel':{
			\"par":"a -> b -> b",
		\},
		\'Control.Parallel.Strategies':{
			\"demanding":"a -> Done -> a",
			\"force":"NFData a => a -> a",
			\"fstPairFstList":"NFData a => Strategy [(a, b)]",
			\"parArr":"Ix b => Strategy a -> Strategy (Array b a)",
			\"parBuffer":"Int -> Strategy a -> [a] -> [a]",
			\"parFlatMap":"Strategy [b] -> (a -> [b]) -> [a] -> [b]",
			\"parList":"Strategy a -> Strategy [a]",
			\"parListChunk":"Int -> Strategy a -> Strategy [a]",
			\"parListN":"Integral b => b -> Strategy a -> Strategy [a]",
			\"parListNth":"Int -> Strategy a -> Strategy [a]",
			\"parMap":"Strategy b -> (a -> b) -> [a] -> [b]",
			\"parPair":"Strategy a -> Strategy b -> Strategy (a, b)",
			\"parTriple":"Strategy a -> Strategy b -> Strategy c -> Strategy (a, b, c)",
			\"parZipWith":"Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]",
			\"r0":"Strategy a",
			\"rnf":"NFData a => Strategy a",
			\"rwhnf":"Strategy a",
			\"sPar":"a -> Strategy b",
			\"sSeq":"a -> Strategy b",
			\"seqArr":"Ix b => Strategy a -> Strategy (Array b a)",
			\"seqList":"Strategy a -> Strategy [a]",
			\"seqListN":"Integral a => a -> Strategy b -> Strategy [b]",
			\"seqListNth":"Int -> Strategy b -> Strategy [b]",
			\"seqPair":"Strategy a -> Strategy b -> Strategy (a, b)",
			\"seqTriple":"Strategy a -> Strategy b -> Strategy c -> Strategy (a, b, c)",
			\"sforce":"NFData a => a -> b -> b",
			\"sparking":"a -> Done -> a",
			\"using":"a -> Strategy a -> a",
		\},
		\'Data.Array':{
			\"accum":"Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e",
			\"accumArray":"Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e",
			\"array":"Ix i => (i, i) -> [(i, e)] -> Array i e",
			\"assocs":"Ix i => Array i e -> [(i, e)]",
			\"bounds":"Ix i => Array i e -> (i, i)",
			\"elems":"Ix i => Array i e -> [e]",
			\"indices":"Ix i => Array i e -> [i]",
			\"ixmap":"(Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e",
			\"listArray":"Ix i => (i, i) -> [e] -> Array i e",
		\},
		\'Data.Array.Diff':{
			\"newDiffArray":"(MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)",
			\"readDiffArray":"(MArray a e IO, Ix i) => IOToDiffArray a i e -> Int -> IO e",
			\"replaceDiffArray":"(MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)",
		\},
		\'Data.Array.IArray':{
			\"accum":"(IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e",
			\"accumArray":"(IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e",
			\"amap":"(IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e",
			\"array":"(IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e",
			\"assocs":"(IArray a e, Ix i) => a i e -> [(i, e)]",
			\"bounds":"(HasBounds a, Ix i) => a i e -> (i, i)",
			\"elems":"(IArray a e, Ix i) => a i e -> [e]",
			\"indices":"(HasBounds a, Ix i) => a i e -> [i]",
			\"ixmap":"(IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e",
			\"listArray":"(IArray a e, Ix i) => (i, i) -> [e] -> a i e",
		\},
		\'Data.Array.IO':{
			\"castIOUArray":"IOUArray ix a -> IO (IOUArray ix b)",
			\"hGetArray":"Handle -> IOUArray Int Word8 -> Int -> IO Int",
			\"hPutArray":"Handle -> IOUArray Int Word8 -> Int -> IO ()",
		\},
		\'Data.Array.MArray':{
			\"freeze":"(Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)",
			\"getAssocs":"(MArray a e m, Ix i) => a i e -> m [(i, e)]",
			\"getElems":"(MArray a e m, Ix i) => a i e -> m [e]",
			\"mapArray":"(MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)",
			\"mapIndices":"(MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)",
			\"newArray":"(MArray a e m, Ix i) => (i, i) -> e -> m (a i e)",
			\"newArray_":"(MArray a e m, Ix i) => (i, i) -> m (a i e)",
			\"newListArray":"(MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)",
			\"readArray":"(MArray a e m, Ix i) => a i e -> i -> m e",
			\"thaw":"(Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)",
			\"unsafeFreeze":"(Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)",
			\"unsafeThaw":"(Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)",
			\"writeArray":"(MArray a e m, Ix i) => a i e -> i -> e -> m ()",
		\},
		\'Data.Array.ST':{
			\"castSTUArray":"STUArray s ix a -> ST s (STUArray s ix b)",
			\"runSTArray":"Ix i => (ST s (STArray s i e)) -> Array i e",
			\"runSTUArray":"Ix i => (ST s (STUArray s i e)) -> UArray i e",
		\},
		\'Data.Array.Storable':{
			\"touchStorableArray":"StorableArray i e -> IO ()",
			\"withStorableArray":"StorableArray i e -> (Ptr e -> IO a) -> IO a",
		\},
		\'Data.Array.Unboxed':{
		\},
		\'Data.Bits':{
			\"bit":"Bits a => Int -> a",
			\"bitSize":"Bits a => a -> Int",
			\"clearBit":"Bits a => a -> Int -> a",
			\"complement":"Bits a => a -> a",
			\"complementBit":"Bits a => a -> Int -> a",
			\"isSigned":"Bits a => a -> Bool",
			\"rotate":"Bits a => a -> Int -> a",
			\"rotateL":"Bits a => a -> Int -> a",
			\"rotateR":"Bits a => a -> Int -> a",
			\"setBit":"Bits a => a -> Int -> a",
			\"shift":"Bits a => a -> Int -> a",
			\"shiftL":"Bits a => a -> Int -> a",
			\"shiftR":"Bits a => a -> Int -> a",
			\"testBit":"Bits a => a -> Int -> Bool",
			\"xor":"Bits a => a -> a -> a",
		\},
		\'Data.Char':{
			\"isLatin1":"Char -> Bool",
		\},
		\'Data.Complex':{
			\"polar":"RealFloat a => Complex a -> (a, a)",
		\},
		\'Data.Dynamic':{
			\"dynApp":"Dynamic -> Dynamic -> Dynamic",
			\"dynApply":"Dynamic -> Dynamic -> Maybe Dynamic",
			\"fromDyn":"Typeable a => Dynamic -> a -> a",
			\"fromDynamic":"Typeable a => Dynamic -> Maybe a",
			\"toDyn":"Typeable a => a -> Dynamic",
		\},
		\'Data.FiniteMap':{
			\"addListToFM":"Ord key => FiniteMap key elt -> [(key, elt)] -> FiniteMap key elt",
			\"addListToFM_C":"Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> [(key, elt)] -> FiniteMap key elt",
			\"addToFM":"Ord key => FiniteMap key elt -> key -> elt -> FiniteMap key elt",
			\"addToFM_C":"Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> key -> elt -> FiniteMap key elt",
			\"delFromFM":"Ord key => FiniteMap key elt -> key -> FiniteMap key elt",
			\"delListFromFM":"Ord key => FiniteMap key elt -> [key] -> FiniteMap key elt",
			\"elemFM":"Ord key => key -> FiniteMap key elt -> Bool",
			\"eltsFM":"FiniteMap key elt -> [elt]",
			\"eltsFM_GE":"Ord key => FiniteMap key elt -> key -> [elt]",
			\"eltsFM_LE":"Ord key => FiniteMap key elt -> key -> [elt]",
			\"emptyFM":"FiniteMap key elt",
			\"filterFM":"Ord key => (key -> elt -> Bool) -> FiniteMap key elt -> FiniteMap key elt",
			\"fmToList":"FiniteMap key elt -> [(key, elt)]",
			\"fmToList_GE":"Ord key => FiniteMap key elt -> key -> [(key, elt)]",
			\"fmToList_LE":"Ord key => FiniteMap key elt -> key -> [(key, elt)]",
			\"foldFM":"(key -> elt -> a -> a) -> a -> FiniteMap key elt -> a",
			\"foldFM_GE":"Ord key => (key -> elt -> a -> a) -> a -> key -> FiniteMap key elt -> a",
			\"foldFM_LE":"Ord key => (key -> elt -> a -> a) -> a -> key -> FiniteMap key elt -> a",
			\"intersectFM":"Ord key => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt",
			\"intersectFM_C":"Ord key => (elt1 -> elt2 -> elt3) -> FiniteMap key elt1 -> FiniteMap key elt2 -> FiniteMap key elt3",
			\"isEmptyFM":"FiniteMap key elt -> Bool",
			\"keysFM":"FiniteMap key elt -> [key]",
			\"keysFM_GE":"Ord key => FiniteMap key elt -> key -> [key]",
			\"keysFM_LE":"Ord key => FiniteMap key elt -> key -> [key]",
			\"listToFM":"Ord key => [(key, elt)] -> FiniteMap key elt",
			\"lookupFM":"Ord key => FiniteMap key elt -> key -> Maybe elt",
			\"lookupWithDefaultFM":"Ord key => FiniteMap key elt -> elt -> key -> elt",
			\"mapFM":"(key -> elt1 -> elt2) -> FiniteMap key elt1 -> FiniteMap key elt2",
			\"maxFM":"Ord key => FiniteMap key elt -> Maybe key",
			\"minFM":"Ord key => FiniteMap key elt -> Maybe key",
			\"minusFM":"Ord key => FiniteMap key elt1 -> FiniteMap key elt2 -> FiniteMap key elt1",
			\"plusFM":"Ord key => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt",
			\"plusFM_C":"Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt",
			\"sizeFM":"FiniteMap key elt -> Int",
			\"unitFM":"key -> elt -> FiniteMap key elt",
		\},
		\'Data.FunctorM':{
			\"fmapM":"(FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)",
			\"fmapM_":"(FunctorM f, Monad m) => (a -> m b) -> f a -> m ()",
		\},
		\'Data.Generics.Aliases':{
			\"choiceMp":"MonadPlus m => GenericM m -> GenericM m -> GenericM m",
			\"choiceQ":"MonadPlus m => GenericQ (m r) -> GenericQ (m r) -> GenericQ (m r)",
			\"ext0":"(Typeable a, Typeable b) => c a -> c b -> c a",
			\"ext1M":"(Monad m, Data d, Typeable1 t) => (d -> m d) -> (t d -> m (t d)) -> d -> m d",
			\"ext1Q":"(Data d, Typeable1 t) => (d -> q) -> (t d -> q) -> d -> q",
			\"ext1R":"(Monad m, Data d, Typeable1 t) => m d -> (m (t d)) -> m d",
			\"ext1T":"(Data d, Typeable1 t) => (d -> d) -> (t d -> t d) -> d -> d",
			\"extB":"(Typeable a, Typeable b) => a -> b -> a",
			\"extM":"(Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a",
			\"extMp":"(MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a",
			\"extQ":"(Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q",
			\"extR":"(Monad m, Typeable a, Typeable b) => m a -> m b -> m a",
			\"extT":"(Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a",
			\"mkM":"(Monad m, Typeable a, Typeable b) => (b -> m b) -> a -> m a",
			\"mkMp":"(MonadPlus m, Typeable a, Typeable b) => (b -> m b) -> a -> m a",
			\"mkQ":"(Typeable a, Typeable b) => r -> (b -> r) -> a -> r",
			\"mkR":"(MonadPlus m, Typeable a, Typeable b) => m b -> m a",
			\"mkT":"(Typeable a, Typeable b) => (b -> b) -> a -> a",
			\"orElse":"Maybe a -> Maybe a -> Maybe a",
			\"recoverMp":"MonadPlus m => GenericM m -> GenericM m",
			\"recoverQ":"MonadPlus m => r -> GenericQ (m r) -> GenericQ (m r)",
			\"unGM":"Data a => GenericM' m -> a -> m a",
			\"unGQ":"GenericQ' r -> GenericQ r",
			\"unGT":"Data a => GenericT' -> a -> a",
			\"unGeneric'":"Generic' c -> Generic c",
		\},
		\'Data.Generics.Basics':{
			\"constrFields":"Constr -> [String]",
			\"constrFixity":"Constr -> Fixity",
			\"constrIndex":"Constr -> ConIndex",
			\"constrRep":"Constr -> ConstrRep",
			\"constrType":"Constr -> DataType",
			\"dataCast1":"(Data a, Typeable1 t) => (c (t a)) -> Maybe (c a)",
			\"dataCast2":"(Data a, Typeable2 t) => (c (t a b)) -> Maybe (c a)",
			\"dataTypeConstrs":"DataType -> [Constr]",
			\"dataTypeName":"DataType -> String",
			\"dataTypeOf":"Data a => a -> DataType",
			\"dataTypeRep":"DataType -> DataRep",
			\"fromConstr":"Data a => Constr -> a",
			\"fromConstrB":"Data a => (a) -> Constr -> a",
			\"fromConstrM":"(Monad m, Data a) => (m a) -> Constr -> m a",
			\"gfoldl":"Data a => (c (a -> b) -> a -> c b) -> (g -> c g) -> a -> c a",
			\"gmapM":"(Data a, Monad m) => (a -> m a) -> a -> m a",
			\"gmapMo":"(Data a, MonadPlus m) => (a -> m a) -> a -> m a",
			\"gmapMp":"(Data a, MonadPlus m) => (a -> m a) -> a -> m a",
			\"gmapQ":"Data a => (a -> u) -> a -> [u]",
			\"gmapQi":"Data a => Int -> (a -> u) -> a -> u",
			\"gmapQl":"Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r",
			\"gmapQr":"Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r",
			\"gmapT":"Data a => (b -> b) -> a -> a",
			\"gunfold":"Data a => (c (b -> r) -> c r) -> (r -> c r) -> Constr -> c a",
			\"indexConstr":"DataType -> ConIndex -> Constr",
			\"isAlgType":"DataType -> Bool",
			\"isNorepType":"DataType -> Bool",
			\"maxConstrIndex":"DataType -> ConIndex",
			\"mkConstr":"DataType -> String -> [String] -> Fixity -> Constr",
			\"mkDataType":"String -> [Constr] -> DataType",
			\"mkFloatConstr":"DataType -> Double -> Constr",
			\"mkFloatType":"String -> DataType",
			\"mkIntConstr":"DataType -> Integer -> Constr",
			\"mkIntType":"String -> DataType",
			\"mkNorepType":"String -> DataType",
			\"mkStringConstr":"DataType -> String -> Constr",
			\"mkStringType":"String -> DataType",
			\"readConstr":"DataType -> String -> Maybe Constr",
			\"repConstr":"DataType -> ConstrRep -> Constr",
			\"showConstr":"Constr -> String",
			\"toConstr":"Data a => a -> Constr",
			\"tyconModule":"String -> String",
			\"tyconUQname":"String -> String",
		\},
		\'Data.Generics.Schemes':{
			\"everything":"(r -> r -> r) -> GenericQ r -> GenericQ r",
			\"everywhere":"(a -> a) -> a -> a",
			\"everywhere'":"(a -> a) -> a -> a",
			\"everywhereBut":"GenericQ Bool -> GenericT -> GenericT",
			\"everywhereM":"Monad m => GenericM m -> GenericM m",
			\"gcount":"GenericQ Bool -> GenericQ Int",
			\"gdepth":"GenericQ Int",
			\"gfindtype":"(Data x, Typeable y) => x -> Maybe y",
			\"glength":"GenericQ Int",
			\"gnodecount":"GenericQ Int",
			\"gsize":"Data a => a -> Int",
			\"gtypecount":"Typeable a => a -> GenericQ Int",
			\"listify":"Typeable r => (r -> Bool) -> GenericQ [r]",
			\"something":"GenericQ (Maybe u) -> GenericQ (Maybe u)",
			\"somewhere":"MonadPlus m => GenericM m -> GenericM m",
			\"synthesize":"s -> (s -> s -> s) -> GenericQ (s -> s) -> GenericQ s",
		\},
		\'Data.Generics.Text':{
			\"gread":"Data a => ReadS a",
			\"gshow":"Data a => a -> String",
		\},
		\'Data.Generics.Twins':{
			\"geq":"Data a => a -> a -> Bool",
			\"gfoldlAccum":"Data d => (a -> c (d -> r) -> d -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)",
			\"gmapAccumM":"(Data d, Monad m) => (a -> d -> (a, m d)) -> a -> d -> (a, m d)",
			\"gmapAccumQ":"Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])",
			\"gmapAccumQl":"Data d => (r -> r' -> r) -> r -> (a -> d -> (a, r')) -> a -> d -> (a, r)",
			\"gmapAccumQr":"Data d => (r' -> r -> r) -> r -> (a -> d -> (a, r')) -> a -> d -> (a, r)",
			\"gmapAccumT":"Data d => (a -> d -> (a, d)) -> a -> d -> (a, d)",
			\"gzip":"(a -> b -> Maybe b) -> a -> b -> Maybe b",
			\"gzipWithM":"Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)",
			\"gzipWithQ":"GenericQ (GenericQ r) -> GenericQ (GenericQ [r])",
			\"gzipWithT":"GenericQ GenericT -> GenericQ GenericT",
		\},
		\'Data.Graph':{
			\"bcc":"Graph -> Forest [Vertex]",
			\"buildG":"Bounds -> [Edge] -> Graph",
			\"components":"Graph -> Forest Vertex",
			\"dff":"Graph -> Forest Vertex",
			\"dfs":"Graph -> [Vertex] -> Forest Vertex",
			\"edges":"Graph -> [Edge]",
			\"flattenSCC":"SCC vertex -> [vertex]",
			\"flattenSCCs":"[SCC a] -> [a]",
			\"graphFromEdges":"Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex)",
			\"graphFromEdges'":"Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]))",
			\"indegree":"Graph -> Table Int",
			\"outdegree":"Graph -> Table Int",
			\"path":"Graph -> Vertex -> Vertex -> Bool",
			\"reachable":"Graph -> Vertex -> [Vertex]",
			\"scc":"Graph -> Forest Vertex",
			\"stronglyConnComp":"Ord key => [(node, key, [key])] -> [SCC node]",
			\"stronglyConnCompR":"Ord key => [(node, key, [key])] -> [SCC (node, key, [key])]",
			\"topSort":"Graph -> [Vertex]",
			\"transposeG":"Graph -> Graph",
			\"vertices":"Graph -> [Vertex]",
		\},
		\'Data.Graph.Inductive':{
			\"version":"IO ()",
		\},
		\'Data.Graph.Inductive.Basic':{
			\"efilter":"DynGraph gr => (LEdge b -> Bool) -> gr a b -> gr a b",
			\"elfilter":"DynGraph gr => (b -> Bool) -> gr a b -> gr a b",
			\"gfold":"Graph gr => (Context a b -> [Node]) -> (Context a b -> c -> d) -> (Maybe d -> c -> c, c) -> [Node] -> gr a b -> c",
			\"grev":"DynGraph gr => gr a b -> gr a b",
			\"gsel":"Graph gr => (Context a b -> Bool) -> gr a b -> [Context a b]",
			\"hasLoop":"Graph gr => gr a b -> Bool",
			\"isSimple":"Graph gr => gr a b -> Bool",
			\"postorder":"Tree a -> [a]",
			\"postorderF":"[Tree a] -> [a]",
			\"preorder":"Tree a -> [a]",
			\"preorderF":"[Tree a] -> [a]",
			\"undir":"(Eq b, DynGraph gr) => gr a b -> gr a b",
			\"unlab":"DynGraph gr => gr a b -> gr () ()",
		\},
		\'Data.Graph.Inductive.Example':{
			\"a":"Gr Char ()",
			\"a'":"IO (SGr Char ())",
			\"ab":"Gr Char ()",
			\"ab'":"IO (SGr Char ())",
			\"abb":"Gr Char ()",
			\"abb'":"IO (SGr Char ())",
			\"b":"Gr Char ()",
			\"b'":"IO (SGr Char ())",
			\"c":"Gr Char ()",
			\"c'":"IO (SGr Char ())",
			\"clr479":"Gr Char ()",
			\"clr479'":"IO (SGr Char ())",
			\"clr486":"Gr String ()",
			\"clr486'":"IO (SGr String ())",
			\"clr489":"Gr Char ()",
			\"clr489'":"IO (SGr Char ())",
			\"clr508":"Gr Char Int",
			\"clr508'":"IO (SGr Char Int)",
			\"clr528":"Gr Char Int",
			\"clr528'":"IO (SGr Char Int)",
			\"clr595":"Gr Int Int",
			\"cyc3":"Gr Char String",
			\"d1":"Gr Int Int",
			\"d1'":"IO (SGr Int Int)",
			\"d3":"Gr Int Int",
			\"d3'":"IO (SGr Int Int)",
			\"dag3":"Gr Char ()",
			\"dag3'":"IO (SGr Char ())",
			\"dag4":"Gr Int ()",
			\"dag4'":"IO (SGr Int ())",
			\"e":"Gr Char ()",
			\"e'":"IO (SGr Char ())",
			\"e3":"Gr () String",
			\"e3'":"IO (SGr () String)",
			\"g3":"Gr Char String",
			\"g3b":"Gr Char String",
			\"genLNodes":"Enum a => a -> Int -> [LNode a]",
			\"genUNodes":"Int -> [UNode]",
			\"gr1":"Gr Int Int",
			\"kin248":"Gr Int ()",
			\"kin248'":"IO (SGr Int ())",
			\"labUEdges":"[Edge] -> [UEdge]",
			\"loop":"Gr Char ()",
			\"loop'":"IO (SGr Char ())",
			\"noEdges":"[UEdge]",
			\"star":"Graph gr => Int -> gr () ()",
			\"starM":"GraphM m gr => Int -> m (gr () ())",
			\"ucycle":"Graph gr => Int -> gr () ()",
			\"ucycleM":"GraphM m gr => Int -> m (gr () ())",
			\"vor":"Gr String Int",
			\"vor'":"IO (SGr String Int)",
		\},
		\'Data.Graph.Inductive.Graph':{
			\"buildGr":"DynGraph gr => [Context a b] -> gr a b",
			\"context":"Graph gr => gr a b -> Node -> Context a b",
			\"deg":"Graph gr => gr a b -> Node -> Int",
			\"deg'":"Context a b -> Int",
			\"delEdge":"DynGraph gr => Edge -> gr a b -> gr a b",
			\"delEdges":"DynGraph gr => [Edge] -> gr a b -> gr a b",
			\"delNode":"Graph gr => Node -> gr a b -> gr a b",
			\"delNodes":"Graph gr => [Node] -> gr a b -> gr a b",
			\"edges":"Graph gr => gr a b -> [Edge]",
			\"emap":"DynGraph gr => (b -> c) -> gr a b -> gr a c",
			\"empty":"Graph gr => gr a b",
			\"equal":"(Eq a, Eq b, Graph gr) => gr a b -> gr a b -> Bool",
			\"gelem":"Graph gr => Node -> gr a b -> Bool",
			\"gmap":"DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d",
			\"indeg":"Graph gr => gr a b -> Node -> Int",
			\"indeg'":"Context a b -> Int",
			\"inn":"Graph gr => gr a b -> Node -> [LEdge b]",
			\"inn'":"Context a b -> [LEdge b]",
			\"insEdge":"DynGraph gr => LEdge b -> gr a b -> gr a b",
			\"insEdges":"DynGraph gr => [LEdge b] -> gr a b -> gr a b",
			\"insNode":"DynGraph gr => LNode a -> gr a b -> gr a b",
			\"insNodes":"DynGraph gr => [LNode a] -> gr a b -> gr a b",
			\"isEmpty":"Graph gr => gr a b -> Bool",
			\"lab":"Graph gr => gr a b -> Node -> Maybe a",
			\"lab'":"Context a b -> a",
			\"labEdges":"Graph gr => gr a b -> [LEdge b]",
			\"labNode'":"Context a b -> LNode a",
			\"labNodes":"Graph gr => gr a b -> [LNode a]",
			\"lpre":"Graph gr => gr a b -> Node -> [(Node, b)]",
			\"lpre'":"Context a b -> [(Node, b)]",
			\"lsuc":"Graph gr => gr a b -> Node -> [(Node, b)]",
			\"lsuc'":"Context a b -> [(Node, b)]",
			\"match":"Graph gr => Node -> gr a b -> Decomp gr a b",
			\"matchAny":"Graph gr => gr a b -> GDecomp gr a b",
			\"mkGraph":"Graph gr => [LNode a] -> [LEdge b] -> gr a b",
			\"mkUGraph":"Graph gr => [Node] -> [Edge] -> gr () ()",
			\"neighbors":"Graph gr => gr a b -> Node -> [Node]",
			\"neighbors'":"Context a b -> [Node]",
			\"newNodes":"Graph gr => Int -> gr a b -> [Node]",
			\"nmap":"DynGraph gr => (a -> c) -> gr a b -> gr c b",
			\"noNodes":"Graph gr => gr a b -> Int",
			\"node'":"Context a b -> Node",
			\"nodeRange":"Graph gr => gr a b -> (Node,Node)",
			\"nodes":"Graph gr => gr a b -> [Node]",
			\"out":"Graph gr => gr a b -> Node -> [LEdge b]",
			\"out'":"Context a b -> [LEdge b]",
			\"outdeg":"Graph gr => gr a b -> Node -> Int",
			\"outdeg'":"Context a b -> Int",
			\"pre":"Graph gr => gr a b -> Node -> [Node]",
			\"pre'":"Context a b -> [Node]",
			\"suc":"Graph gr => gr a b -> Node -> [Node]",
			\"suc'":"Context a b -> [Node]",
			\"ufold":"Graph gr => (Context a b -> c -> c) -> c -> gr a b -> c",
		\},
		\'Data.Graph.Inductive.Graphviz':{
			\"graphviz":"(Graph g, Show a, Show b) => g a b -> String -> (Double, Double) -> (Int, Int) -> Orient -> String",
			\"graphviz'":"(Graph g, Show a, Show b) => g a b -> String",
		\},
		\'Data.Graph.Inductive.Internal.FiniteMap':{
			\"accumFM":"Ord a => FiniteMap a b -> a -> (b -> b -> b) -> b -> FiniteMap a b",
			\"addToFM":"Ord a => FiniteMap a b -> a -> b -> FiniteMap a b",
			\"delFromFM":"Ord a => FiniteMap a b -> a -> FiniteMap a b",
			\"elemFM":"Ord a => FiniteMap a b -> a -> Bool",
			\"emptyFM":"Ord a => FiniteMap a b",
			\"fmToList":"Ord a => FiniteMap a b -> [(a, b)]",
			\"isEmptyFM":"FiniteMap a b -> Bool",
			\"lookupFM":"Ord a => FiniteMap a b -> a -> Maybe b",
			\"maxFM":"Ord a => FiniteMap a b -> Maybe (a, b)",
			\"minFM":"Ord a => FiniteMap a b -> Maybe (a, b)",
			\"predFM":"Ord a => FiniteMap a b -> a -> Maybe (a, b)",
			\"rangeFM":"Ord a => FiniteMap a b -> a -> a -> [b]",
			\"sizeFM":"Ord a => FiniteMap a b -> Int",
			\"splitFM":"Ord a => FiniteMap a b -> a -> Maybe (FiniteMap a b, (a, b))",
			\"splitMinFM":"Ord a => FiniteMap a b -> Maybe (FiniteMap a b, (a, b))",
			\"succFM":"Ord a => FiniteMap a b -> a -> Maybe (a, b)",
			\"updFM":"Ord a => FiniteMap a b -> a -> (b -> b) -> FiniteMap a b",
		\},
		\'Data.Graph.Inductive.Internal.Heap':{
			\"build":"Ord a => [(a, b)] -> Heap a b",
			\"deleteMin":"Ord a => Heap a b -> Heap a b",
			\"empty":"Ord a => Heap a b",
			\"findMin":"Ord a => Heap a b -> (a, b)",
			\"heapsort":"Ord a => [a] -> [a]",
			\"insert":"Ord a => (a, b) -> Heap a b -> Heap a b",
			\"isEmpty":"Ord a => Heap a b -> Bool",
			\"merge":"Ord a => Heap a b -> Heap a b -> Heap a b",
			\"mergeAll":"Ord a => [Heap a b] -> Heap a b",
			\"splitMin":"Ord a => Heap a b -> (a, b, Heap a b)",
			\"toList":"Ord a => Heap a b -> [(a, b)]",
			\"unit":"Ord a => a -> b -> Heap a b",
		\},
		\'Data.Graph.Inductive.Internal.Queue':{
			\"mkQueue":"Queue a",
			\"queueEmpty":"Queue a -> Bool",
			\"queueGet":"Queue a -> (a, Queue a)",
			\"queuePut":"a -> Queue a -> Queue a",
			\"queuePutList":"[a] -> Queue a -> Queue a",
		\},
		\'Data.Graph.Inductive.Internal.RootPath':{
			\"getDistance":"Node -> LRTree a -> a",
			\"getLPath":"Node -> LRTree a -> LPath a",
			\"getLPathNodes":"Node -> LRTree a -> Path",
			\"getPath":"Node -> RTree -> Path",
		\},
		\'Data.Graph.Inductive.Internal.Thread':{
			\"splitPar":"Split t i r -> Split u j s -> Split (t, u) (i, j) (r, s)",
			\"splitParM":"SplitM t i r -> Split u j s -> SplitM (t, u) (i, j) (r, s)",
			\"threadList":"Collect r c -> Split t i r -> [i] -> t -> (c, t)",
			\"threadList'":"Collect r c -> Split t i r -> [i] -> t -> (c, t)",
			\"threadMaybe":"(i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a",
			\"threadMaybe'":"(r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)",
		\},
		\'Data.Graph.Inductive.Monad':{
			\"contextM":"GraphM m gr => m (gr a b) -> Node -> m (Context a b)",
			\"delNodeM":"GraphM m gr => Node -> m (gr a b) -> m (gr a b)",
			\"delNodesM":"GraphM m gr => [Node] -> m (gr a b) -> m (gr a b)",
			\"edgesM":"GraphM m gr => m (gr a b) -> m [Edge]",
			\"emptyM":"GraphM m gr => m (gr a b)",
			\"isEmptyM":"GraphM m gr => m (gr a b) -> m Bool",
			\"labEdgesM":"GraphM m gr => m (gr a b) -> m [LEdge b]",
			\"labM":"GraphM m gr => m (gr a b) -> Node -> m (Maybe a)",
			\"labNodesM":"GraphM m gr => m (gr a b) -> m [LNode a]",
			\"matchAnyM":"GraphM m gr => m (gr a b) -> m (GDecomp gr a b)",
			\"matchM":"GraphM m gr => Node -> m (gr a b) -> m (Decomp gr a b)",
			\"mkGraphM":"GraphM m gr => [LNode a] -> [LEdge b] -> m (gr a b)",
			\"mkUGraphM":"GraphM m gr => [Node] -> [Edge] -> m (gr () ())",
			\"newNodesM":"GraphM m gr => Int -> m (gr a b) -> m [Node]",
			\"noNodesM":"GraphM m gr => m (gr a b) -> m Int",
			\"nodeRangeM":"GraphM m gr => m (gr a b) -> m (Node,Node)",
			\"nodesM":"GraphM m gr => m (gr a b) -> m [Node]",
			\"ufoldM":"GraphM m gr => (Context a b -> c -> c) -> c -> m (gr a b) -> m c",
		\},
		\'Data.Graph.Inductive.Monad.IOArray':{
			\"defaultGraphSize":"Int",
			\"emptyN":"Int -> IO (SGr a b)",
			\"removeDel":"IOArray Node Bool -> Adj b -> IO (Adj b)",
		\},
		\'Data.Graph.Inductive.NodeMap':{
			\"delMapEdge":"(Ord a, DynGraph g) => NodeMap a -> (a, a) -> g a b -> g a b",
			\"delMapEdgeM":"(Ord a, DynGraph g) => (a, a) -> NodeMapM a b g ()",
			\"delMapEdges":"(Ord a, DynGraph g) => NodeMap a -> [(a, a)] -> g a b -> g a b",
			\"delMapEdgesM":"(Ord a, DynGraph g) => [(a, a)] -> NodeMapM a b g ()",
			\"delMapNode":"(Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b",
			\"delMapNodeM":"(Ord a, DynGraph g) => a -> NodeMapM a b g ()",
			\"delMapNodes":"(Ord a, DynGraph g) => NodeMap a -> [a] -> g a b -> g a b",
			\"delMapNodesM":"(Ord a, DynGraph g) => [a] -> NodeMapM a b g ()",
			\"fromGraph":"(Ord a, Graph g) => g a b -> NodeMap a",
			\"insMapEdge":"(Ord a, DynGraph g) => NodeMap a -> (a, a, b) -> g a b -> g a b",
			\"insMapEdgeM":"(Ord a, DynGraph g) => (a, a, b) -> NodeMapM a b g ()",
			\"insMapEdges":"(Ord a, DynGraph g) => NodeMap a -> [(a, a, b)] -> g a b -> g a b",
			\"insMapEdgesM":"(Ord a, DynGraph g) => [(a, a, b)] -> NodeMapM a b g ()",
			\"insMapNode":"(Ord a, DynGraph g) => NodeMap a -> a -> g a b -> (g a b, NodeMap a, LNode a)",
			\"insMapNodeM":"(Ord a, DynGraph g) => a -> NodeMapM a b g (LNode a)",
			\"insMapNode_":"(Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b",
			\"insMapNodes":"(Ord a, DynGraph g) => NodeMap a -> [a] -> g a b -> (g a b, NodeMap a, [LNode a])",
			\"insMapNodesM":"(Ord a, DynGraph g) => [a] -> NodeMapM a b g [LNode a]",
			\"insMapNodes_":"(Ord a, DynGraph g) => NodeMap a -> [a] -> g a b -> g a b",
			\"mkEdge":"Ord a => NodeMap a -> (a, a, b) -> Maybe (LEdge b)",
			\"mkEdgeM":"(Ord a, DynGraph g) => (a, a, b) -> NodeMapM a b g (Maybe (LEdge b))",
			\"mkEdges":"Ord a => NodeMap a -> [(a, a, b)] -> Maybe [LEdge b]",
			\"mkEdgesM":"(Ord a, DynGraph g) => [(a, a, b)] -> NodeMapM a b g (Maybe [LEdge b])",
			\"mkMapGraph":"(Ord a, DynGraph g) => [a] -> [(a, a, b)] -> (g a b, NodeMap a)",
			\"mkNode":"Ord a => NodeMap a -> a -> (LNode a, NodeMap a)",
			\"mkNodeM":"(Ord a, DynGraph g) => a -> NodeMapM a b g (LNode a)",
			\"mkNode_":"Ord a => NodeMap a -> a -> LNode a",
			\"mkNodes":"Ord a => NodeMap a -> [a] -> ([LNode a], NodeMap a)",
			\"mkNodesM":"(Ord a, DynGraph g) => [a] -> NodeMapM a b g [LNode a]",
			\"mkNodes_":"Ord a => NodeMap a -> [a] -> [LNode a]",
			\"new":"Ord a => NodeMap a",
			\"run":"(DynGraph g, Ord a) => g a b -> NodeMapM a b g r -> (r, (NodeMap a, g a b))",
			\"run_":"(DynGraph g, Ord a) => g a b -> NodeMapM a b g r -> g a b",
		\},
		\'Data.Graph.Inductive.Query.ArtPoint':{
			\"ap":"Graph gr => gr a b -> [Node]",
		\},
		\'Data.Graph.Inductive.Query.BCC':{
			\"bcc":"DynGraph gr => gr a b -> [gr a b]",
		\},
		\'Data.Graph.Inductive.Query.BFS':{
			\"bfe":"Graph gr => Node -> gr a b -> [Edge]",
			\"bfen":"Graph gr => [Edge] -> gr a b -> [Edge]",
			\"bfs":"Graph gr => Node -> gr a b -> [Node]",
			\"bfsWith":"Graph gr => (Context a b -> c) -> Node -> gr a b -> [c]",
			\"bfsn":"Graph gr => [Node] -> gr a b -> [Node]",
			\"bfsnWith":"Graph gr => (Context a b -> c) -> [Node] -> gr a b -> [c]",
			\"bft":"Graph gr => Node -> gr a b -> RTree",
			\"esp":"Graph gr => Node -> Node -> gr a b -> Path",
			\"lbft":"Graph gr => Node -> gr a b -> LRTree b",
			\"lesp":"Graph gr => Node -> Node -> gr a b -> LPath b",
			\"level":"Graph gr => Node -> gr a b -> [(Node, Int)]",
			\"leveln":"Graph gr => [(Node, Int)] -> gr a b -> [(Node, Int)]",
		\},
		\'Data.Graph.Inductive.Query.DFS':{
			\"components":"Graph gr => gr a b -> [[Node]]",
			\"dff":"Graph gr => [Node] -> gr a b -> [Tree Node]",
			\"dff'":"Graph gr => gr a b -> [Tree Node]",
			\"dffWith":"Graph gr => CFun a b c -> [Node] -> gr a b -> [Tree c]",
			\"dffWith'":"Graph gr => CFun a b c -> gr a b -> [Tree c]",
			\"dfs":"Graph gr => [Node] -> gr a b -> [Node]",
			\"dfs'":"Graph gr => gr a b -> [Node]",
			\"dfsWith":"Graph gr => CFun a b c -> [Node] -> gr a b -> [c]",
			\"dfsWith'":"Graph gr => CFun a b c -> gr a b -> [c]",
			\"isConnected":"Graph gr => gr a b -> Bool",
			\"noComponents":"Graph gr => gr a b -> Int",
			\"rdff":"Graph gr => [Node] -> gr a b -> [Tree Node]",
			\"rdff'":"Graph gr => gr a b -> [Tree Node]",
			\"rdfs":"Graph gr => [Node] -> gr a b -> [Node]",
			\"rdfs'":"Graph gr => gr a b -> [Node]",
			\"reachable":"Graph gr => Node -> gr a b -> [Node]",
			\"scc":"Graph gr => gr a b -> [[Node]]",
			\"topsort":"Graph gr => gr a b -> [Node]",
			\"topsort'":"Graph gr => gr a b -> [a]",
			\"udff":"Graph gr => [Node] -> gr a b -> [Tree Node]",
			\"udff'":"Graph gr => gr a b -> [Tree Node]",
			\"udfs":"Graph gr => [Node] -> gr a b -> [Node]",
			\"udfs'":"Graph gr => gr a b -> [Node]",
		\},
		\'Data.Graph.Inductive.Query.Dominators':{
			\"dom":"Graph gr => gr a b -> Node -> [(Node, [Node])]",
		\},
		\'Data.Graph.Inductive.Query.GVD':{
			\"gvdIn":"(DynGraph gr, Real b) => [Node] -> gr a b -> Voronoi b",
			\"gvdOut":"(Graph gr, Real b) => [Node] -> gr a b -> Voronoi b",
			\"nearestDist":"Real b => Node -> Voronoi b -> Maybe b",
			\"nearestNode":"Real b => Node -> Voronoi b -> Maybe Node",
			\"nearestPath":"Real b => Node -> Voronoi b -> Maybe Path",
			\"voronoiSet":"Real b => Node -> Voronoi b -> [Node]",
		\},
		\'Data.Graph.Inductive.Query.Indep':{
			\"indep":"DynGraph gr => gr a b -> [Node]",
		\},
		\'Data.Graph.Inductive.Query.MST':{
			\"msPath":"Real b => LRTree b -> Node -> Node -> Path",
			\"msTree":"(Graph gr, Real b) => gr a b -> LRTree b",
			\"msTreeAt":"(Graph gr, Real b) => Node -> gr a b -> LRTree b",
		\},
		\'Data.Graph.Inductive.Query.MaxFlow':{
			\"augmentGraph":"(DynGraph gr, Num b, Ord b) => gr a b -> gr a (b, b, b)",
			\"getRevEdges":"(Num b, Ord b) => [(Node, Node)] -> [(Node, Node, b)]",
			\"maxFlow":"(DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> b",
			\"maxFlowgraph":"(DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> gr a (b, b)",
			\"mf":"(DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> gr a (b, b, b)",
			\"mfmg":"(DynGraph gr, Num b, Ord b) => gr a (b, b, b) -> Node -> Node -> gr a (b, b, b)",
			\"updAdjList":"(Num b, Ord b) => [((b, b, b), Node)] -> Node -> b -> Bool -> [((b, b, b), Node)]",
			\"updateFlow":"(DynGraph gr, Num b, Ord b) => Path -> b -> gr a (b, b, b) -> gr a (b, b, b)",
		\},
		\'Data.Graph.Inductive.Query.MaxFlow2':{
			\"ekFused":"Network -> Node -> Node -> (Network, Double)",
			\"ekList":"Network -> Node -> Node -> (Network, Double)",
			\"ekSimple":"Network -> Node -> Node -> (Network, Double)",
		\},
		\'Data.Graph.Inductive.Query.Monad':{
			\"apply":"GT m g a -> m g -> m (a, g)",
			\"apply'":"Monad m => GT m g a -> g -> m (a, g)",
			\"applyWith":"Monad m => (a -> b) -> GT m g a -> m g -> m (b, g)",
			\"applyWith'":"Monad m => (a -> b) -> GT m g a -> g -> m (b, g)",
			\"condMGT":"Monad m => (m s -> m Bool) -> GT m s a -> GT m s a -> GT m s a",
			\"condMGT'":"Monad m => (s -> Bool) -> GT m s a -> GT m s a -> GT m s a",
			\"dffM":"GraphM m gr => [Node] -> GT m (gr a b) [Tree Node]",
			\"dfsGT":"GraphM m gr => [Node] -> GT m (gr a b) [Node]",
			\"dfsM":"GraphM m gr => [Node] -> m (gr a b) -> m [Node]",
			\"dfsM'":"GraphM m gr => m (gr a b) -> m [Node]",
			\"getContext":"GraphM m gr => GT m (gr a b) (Context a b)",
			\"getNode":"GraphM m gr => GT m (gr a b) Node",
			\"getNodes":"GraphM m gr => GT m (gr a b) [Node]",
			\"getNodes'":"(Graph gr, GraphM m gr) => GT m (gr a b) [Node]",
			\"graphDff":"GraphM m gr => [Node] -> m (gr a b) -> m [Tree Node]",
			\"graphDff'":"GraphM m gr => m (gr a b) -> m [Tree Node]",
			\"graphFilter":"GraphM m gr => (Context a b -> Bool) -> m (gr a b) -> m [Context a b]",
			\"graphFilterM":"GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]",
			\"graphNodes":"GraphM m gr => m (gr a b) -> m [Node]",
			\"graphNodesM":"GraphM m gr => GT m (gr a b) [Node]",
			\"graphNodesM0":"GraphM m gr => GT m (gr a b) [Node]",
			\"graphRec":"GraphM m gr => GT m (gr a b) c -> (c -> d -> d) -> d -> GT m (gr a b) d",
			\"graphRec'":"(Graph gr, GraphM m gr) => GT m (gr a b) c -> (c -> d -> d) -> d -> GT m (gr a b) d",
			\"graphUFold":"GraphM m gr => (Context a b -> c -> c) -> c -> GT m (gr a b) c",
			\"mapFst":"(a -> b) -> (a, c) -> (b, c)",
			\"mapSnd":"(a -> b) -> (c, a) -> (c, b)",
			\"orP":"(a -> Bool) -> (b -> Bool) -> (a, b) -> Bool",
			\"recMGT":"Monad m => (m s -> m Bool) -> GT m s a -> (a -> b -> b) -> b -> GT m s b",
			\"recMGT'":"Monad m => (s -> Bool) -> GT m s a -> (a -> b -> b) -> b -> GT m s b",
			\"runGT":"Monad m => GT m g a -> m g -> m a",
			\"sucGT":"GraphM m gr => Node -> GT m (gr a b) (Maybe [Node])",
			\"sucM":"GraphM m gr => Node -> m (gr a b) -> m (Maybe [Node])",
		\},
		\'Data.Graph.Inductive.Query.SP':{
			\"dijkstra":"(Graph gr, Real b) => Heap b (LPath b) -> gr a b -> LRTree b",
			\"sp":"(Graph gr, Real b) => Node -> Node -> gr a b -> Path",
			\"spLength":"(Graph gr, Real b) => Node -> Node -> gr a b -> b",
			\"spTree":"(Graph gr, Real b) => Node -> gr a b -> LRTree b",
		\},
		\'Data.Graph.Inductive.Query.TransClos':{
			\"trc":"DynGraph gr => gr a b -> gr a ()",
		\},
		\'Data.Graph.Inductive.Tree':{
		\},
		\'Data.HashTable':{
			\"delete":"HashTable key val -> key -> IO ()",
			\"fromList":"Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)",
			\"hashInt":"Int -> Int32",
			\"hashString":"String -> Int32",
			\"insert":"HashTable key val -> key -> val -> IO ()",
			\"longestChain":"HashTable key val -> IO [(key, val)]",
			\"lookup":"HashTable key val -> key -> IO (Maybe val)",
			\"new":"(key -> key -> Bool) -> (key -> Int32) -> IO (HashTable key val)",
			\"prime":"Int32",
			\"toList":"HashTable key val -> IO [(key, val)]",
			\"update":"HashTable key val -> key -> val -> IO Bool",
		\},
		\'Data.IORef':{
			\"atomicModifyIORef":"IORef a -> (a -> (a, b)) -> IO b",
			\"mkWeakIORef":"IORef a -> IO () -> IO (Weak (IORef a))",
			\"modifyIORef":"IORef a -> (a -> a) -> IO ()",
			\"newIORef":"a -> IO (IORef a)",
			\"readIORef":"IORef a -> IO a",
			\"writeIORef":"IORef a -> a -> IO ()",
		\},
		\'Data.Int':{
		\},
		\'Data.IntMap':{
			\"adjust":"(a -> a) -> Key -> IntMap a -> IntMap a",
			\"adjustWithKey":"(Key -> a -> a) -> Key -> IntMap a -> IntMap a",
			\"assocs":"IntMap a -> [(Key, a)]",
			\"delete":"Key -> IntMap a -> IntMap a",
			\"difference":"IntMap a -> IntMap b -> IntMap a",
			\"differenceWith":"(a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a",
			\"differenceWithKey":"(Key -> a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a",
			\"elems":"IntMap a -> [a]",
			\"empty":"IntMap a",
			\"filter":"(a -> Bool) -> IntMap a -> IntMap a",
			\"filterWithKey":"(Key -> a -> Bool) -> IntMap a -> IntMap a",
			\"findWithDefault":"a -> Key -> IntMap a -> a",
			\"fold":"(a -> b -> b) -> b -> IntMap a -> b",
			\"foldWithKey":"(Key -> a -> b -> b) -> b -> IntMap a -> b",
			\"fromAscList":"[(Key, a)] -> IntMap a",
			\"fromAscListWith":"(a -> a -> a) -> [(Key, a)] -> IntMap a",
			\"fromAscListWithKey":"(Key -> a -> a -> a) -> [(Key, a)] -> IntMap a",
			\"fromDistinctAscList":"[(Key, a)] -> IntMap a",
			\"fromList":"[(Key, a)] -> IntMap a",
			\"fromListWith":"(a -> a -> a) -> [(Key, a)] -> IntMap a",
			\"fromListWithKey":"(Key -> a -> a -> a) -> [(Key, a)] -> IntMap a",
			\"insert":"Key -> a -> IntMap a -> IntMap a",
			\"insertLookupWithKey":"(Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)",
			\"insertWith":"(a -> a -> a) -> Key -> a -> IntMap a -> IntMap a",
			\"insertWithKey":"(Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a",
			\"intersection":"IntMap a -> IntMap b -> IntMap a",
			\"intersectionWith":"(a -> b -> a) -> IntMap a -> IntMap b -> IntMap a",
			\"intersectionWithKey":"(Key -> a -> b -> a) -> IntMap a -> IntMap b -> IntMap a",
			\"isProperSubmapOf":"Eq a => IntMap a -> IntMap a -> Bool",
			\"isProperSubmapOfBy":"(a -> b -> Bool) -> IntMap a -> IntMap b -> Bool",
			\"isSubmapOf":"Eq a => IntMap a -> IntMap a -> Bool",
			\"isSubmapOfBy":"(a -> b -> Bool) -> IntMap a -> IntMap b -> Bool",
			\"keys":"IntMap a -> [Key]",
			\"keysSet":"IntMap a -> IntSet",
			\"lookup":"Key -> IntMap a -> Maybe a",
			\"map":"(a -> b) -> IntMap a -> IntMap b",
			\"mapAccum":"(a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)",
			\"mapAccumWithKey":"(a -> Key -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)",
			\"mapWithKey":"(Key -> a -> b) -> IntMap a -> IntMap b",
			\"member":"Key -> IntMap a -> Bool",
			\"null":"IntMap a -> Bool",
			\"partition":"(a -> Bool) -> IntMap a -> (IntMap a, IntMap a)",
			\"partitionWithKey":"(Key -> a -> Bool) -> IntMap a -> (IntMap a, IntMap a)",
			\"showTree":"Show a => IntMap a -> String",
			\"showTreeWith":"Show a => Bool -> Bool -> IntMap a -> String",
			\"singleton":"Key -> a -> IntMap a",
			\"size":"IntMap a -> Int",
			\"split":"Key -> IntMap a -> (IntMap a, IntMap a)",
			\"splitLookup":"Key -> IntMap a -> (IntMap a, Maybe a, IntMap a)",
			\"toAscList":"IntMap a -> [(Key, a)]",
			\"toList":"IntMap a -> [(Key, a)]",
			\"union":"IntMap a -> IntMap a -> IntMap a",
			\"unionWith":"(a -> a -> a) -> IntMap a -> IntMap a -> IntMap a",
			\"unionWithKey":"(Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a",
			\"unions":"[IntMap a] -> IntMap a",
			\"unionsWith":"(a -> a -> a) -> [IntMap a] -> IntMap a",
			\"update":"(a -> Maybe a) -> Key -> IntMap a -> IntMap a",
			\"updateLookupWithKey":"(Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a, IntMap a)",
			\"updateWithKey":"(Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a",
		\},
		\'Data.IntSet':{
			\"delete":"Int -> IntSet -> IntSet",
			\"difference":"IntSet -> IntSet -> IntSet",
			\"elems":"IntSet -> [Int]",
			\"empty":"IntSet",
			\"filter":"(Int -> Bool) -> IntSet -> IntSet",
			\"fold":"(Int -> b -> b) -> b -> IntSet -> b",
			\"fromAscList":"[Int] -> IntSet",
			\"fromDistinctAscList":"[Int] -> IntSet",
			\"fromList":"[Int] -> IntSet",
			\"insert":"Int -> IntSet -> IntSet",
			\"intersection":"IntSet -> IntSet -> IntSet",
			\"isProperSubsetOf":"IntSet -> IntSet -> Bool",
			\"isSubsetOf":"IntSet -> IntSet -> Bool",
			\"map":"(Int -> Int) -> IntSet -> IntSet",
			\"member":"Int -> IntSet -> Bool",
			\"null":"IntSet -> Bool",
			\"partition":"(Int -> Bool) -> IntSet -> (IntSet, IntSet)",
			\"showTree":"IntSet -> String",
			\"showTreeWith":"Bool -> Bool -> IntSet -> String",
			\"singleton":"Int -> IntSet",
			\"size":"IntSet -> Int",
			\"split":"Int -> IntSet -> (IntSet, IntSet)",
			\"splitMember":"Int -> IntSet -> (IntSet, Bool, IntSet)",
			\"toAscList":"IntSet -> [Int]",
			\"toList":"IntSet -> [Int]",
			\"union":"IntSet -> IntSet -> IntSet",
			\"unions":"[IntSet] -> IntSet",
		\},
		\'Data.Ix':{
		\},
		\'Data.List':{
			\"deleteFirstsBy":"(a -> a -> Bool) -> [a] -> [a] -> [a]",
			\"elemIndex":"Eq a => a -> [a] -> Maybe Int",
			\"foldl'":"(a -> b -> a) -> a -> [b] -> a",
			\"foldl1'":"(a -> a -> a) -> [a] -> a",
			\"genericDrop":"Integral i => i -> [a] -> [a]",
			\"genericLength":"Num i => [b] -> i",
			\"genericReplicate":"Integral i => i -> a -> [a]",
			\"genericSplitAt":"Integral i => i -> [b] -> ([b], [b])",
			\"genericTake":"Integral i => i -> [a] -> [a]",
			\"mapAccumL":"(acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])",
			\"mapAccumR":"(acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])",
			\"maximumBy":"(a -> a -> Ordering) -> [a] -> a",
			\"minimumBy":"(a -> a -> Ordering) -> [a] -> a",
			\"partition":"(a -> Bool) -> [a] -> ([a], [a])",
			\"unfoldr":"(b -> Maybe (a, b)) -> b -> [a]",
			\"unzip4":"[(a, b, c, d)] -> ([a], [b], [c], [d])",
			\"unzip5":"[(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])",
			\"unzip6":"[(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])",
			\"unzip7":"[(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])",
			\"zip4":"[a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]",
			\"zip5":"[a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]",
			\"zip6":"[a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]",
			\"zip7":"[a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]",
		\},
		\'Data.Map':{
			\"adjust":"Ord k => (a -> a) -> k -> Map k a -> Map k a",
			\"adjustWithKey":"Ord k => (k -> a -> a) -> k -> Map k a -> Map k a",
			\"assocs":"Map k a -> [(k, a)]",
			\"delete":"Ord k => k -> Map k a -> Map k a",
			\"deleteAt":"Int -> Map k a -> Map k a",
			\"deleteFindMax":"Map k a -> ((k, a), Map k a)",
			\"deleteFindMin":"Map k a -> ((k, a), Map k a)",
			\"deleteMax":"Map k a -> Map k a",
			\"deleteMin":"Map k a -> Map k a",
			\"difference":"Ord k => Map k a -> Map k b -> Map k a",
			\"differenceWith":"Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a",
			\"differenceWithKey":"Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a",
			\"elemAt":"Int -> Map k a -> (k, a)",
			\"elems":"Map k a -> [a]",
			\"empty":"Map k a",
			\"filter":"Ord k => (a -> Bool) -> Map k a -> Map k a",
			\"filterWithKey":"Ord k => (k -> a -> Bool) -> Map k a -> Map k a",
			\"findIndex":"Ord k => k -> Map k a -> Int",
			\"findMax":"Map k a -> (k, a)",
			\"findMin":"Map k a -> (k, a)",
			\"findWithDefault":"Ord k => a -> k -> Map k a -> a",
			\"fold":"(a -> b -> b) -> b -> Map k a -> b",
			\"foldWithKey":"(k -> a -> b -> b) -> b -> Map k a -> b",
			\"fromAscList":"Eq k => [(k, a)] -> Map k a",
			\"fromAscListWith":"Eq k => (a -> a -> a) -> [(k, a)] -> Map k a",
			\"fromAscListWithKey":"Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a",
			\"fromDistinctAscList":"[(k, a)] -> Map k a",
			\"fromList":"Ord k => [(k, a)] -> Map k a",
			\"fromListWith":"Ord k => (a -> a -> a) -> [(k, a)] -> Map k a",
			\"fromListWithKey":"Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a",
			\"insert":"Ord k => k -> a -> Map k a -> Map k a",
			\"insertLookupWithKey":"Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)",
			\"insertWith":"Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a",
			\"insertWithKey":"Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a",
			\"intersection":"Ord k => Map k a -> Map k b -> Map k a",
			\"intersectionWith":"Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c",
			\"intersectionWithKey":"Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c",
			\"isProperSubmapOf":"(Ord k, Eq a) => Map k a -> Map k a -> Bool",
			\"isProperSubmapOfBy":"Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool",
			\"isSubmapOf":"(Ord k, Eq a) => Map k a -> Map k a -> Bool",
			\"isSubmapOfBy":"Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool",
			\"keys":"Map k a -> [k]",
			\"keysSet":"Map k a -> Set k",
			\"lookup":"(Monad m, Ord k) => k -> Map k a -> m a",
			\"lookupIndex":"(Monad m, Ord k) => k -> Map k a -> m Int",
			\"map":"(a -> b) -> Map k a -> Map k b",
			\"mapAccum":"(a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)",
			\"mapAccumWithKey":"(a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)",
			\"mapKeys":"Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a",
			\"mapKeysMonotonic":"(k1 -> k2) -> Map k1 a -> Map k2 a",
			\"mapKeysWith":"Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a",
			\"mapWithKey":"(k -> a -> b) -> Map k a -> Map k b",
			\"member":"Ord k => k -> Map k a -> Bool",
			\"null":"Map k a -> Bool",
			\"partition":"Ord k => (a -> Bool) -> Map k a -> (Map k a, Map k a)",
			\"partitionWithKey":"Ord k => (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)",
			\"showTree":"(Show k, Show a) => Map k a -> String",
			\"showTreeWith":"(k -> a -> String) -> Bool -> Bool -> Map k a -> String",
			\"singleton":"k -> a -> Map k a",
			\"size":"Map k a -> Int",
			\"split":"Ord k => k -> Map k a -> (Map k a, Map k a)",
			\"splitLookup":"Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)",
			\"toAscList":"Map k a -> [(k, a)]",
			\"toList":"Map k a -> [(k, a)]",
			\"union":"Ord k => Map k a -> Map k a -> Map k a",
			\"unionWith":"Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a",
			\"unionWithKey":"Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a",
			\"unions":"Ord k => [Map k a] -> Map k a",
			\"unionsWith":"Ord k => (a -> a -> a) -> [Map k a] -> Map k a",
			\"update":"Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a",
			\"updateAt":"(k -> a -> Maybe a) -> Int -> Map k a -> Map k a",
			\"updateLookupWithKey":"Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)",
			\"updateMax":"(a -> Maybe a) -> Map k a -> Map k a",
			\"updateMaxWithKey":"(k -> a -> Maybe a) -> Map k a -> Map k a",
			\"updateMin":"(a -> Maybe a) -> Map k a -> Map k a",
			\"updateMinWithKey":"(k -> a -> Maybe a) -> Map k a -> Map k a",
			\"updateWithKey":"Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a",
			\"valid":"Ord k => Map k a -> Bool",
		\},
		\'Data.Monoid':{
			\"mappend":"Monoid a => a -> a -> a",
			\"mconcat":"Monoid a => [a] -> a",
			\"mempty":"Monoid a => a",
		\},
		\'Data.PackedString':{
			\"appendPS":"PackedString -> PackedString -> PackedString",
			\"breakPS":"(Char -> Bool) -> PackedString -> (PackedString, PackedString)",
			\"concatPS":"[PackedString] -> PackedString",
			\"consPS":"Char -> PackedString -> PackedString",
			\"dropPS":"Int -> PackedString -> PackedString",
			\"dropWhilePS":"(Char -> Bool) -> PackedString -> PackedString",
			\"elemPS":"Char -> PackedString -> Bool",
			\"filterPS":"(Char -> Bool) -> PackedString -> PackedString",
			\"foldlPS":"(a -> Char -> a) -> a -> PackedString -> a",
			\"foldrPS":"(Char -> a -> a) -> a -> PackedString -> a",
			\"hGetPS":"Handle -> Int -> IO PackedString",
			\"hPutPS":"Handle -> PackedString -> IO ()",
			\"headPS":"PackedString -> Char",
			\"indexPS":"PackedString -> Int -> Char",
			\"joinPS":"PackedString -> [PackedString] -> PackedString",
			\"lengthPS":"PackedString -> Int",
			\"linesPS":"PackedString -> [PackedString]",
			\"mapPS":"(Char -> Char) -> PackedString -> PackedString",
			\"nilPS":"PackedString",
			\"nullPS":"PackedString -> Bool",
			\"packString":"String -> PackedString",
			\"reversePS":"PackedString -> PackedString",
			\"spanPS":"(Char -> Bool) -> PackedString -> (PackedString, PackedString)",
			\"splitAtPS":"Int -> PackedString -> (PackedString, PackedString)",
			\"splitPS":"Char -> PackedString -> [PackedString]",
			\"splitWithPS":"(Char -> Bool) -> PackedString -> [PackedString]",
			\"substrPS":"PackedString -> Int -> Int -> PackedString",
			\"tailPS":"PackedString -> PackedString",
			\"takePS":"Int -> PackedString -> PackedString",
			\"takeWhilePS":"(Char -> Bool) -> PackedString -> PackedString",
			\"unlinesPS":"[PackedString] -> PackedString",
			\"unpackPS":"PackedString -> String",
			\"unwordsPS":"[PackedString] -> PackedString",
			\"wordsPS":"PackedString -> [PackedString]",
		\},
		\'Data.Queue':{
			\"addToQueue":"Queue a -> a -> Queue a",
			\"deQueue":"Queue a -> Maybe (a, Queue a)",
			\"emptyQueue":"Queue a",
			\"listToQueue":"[a] -> Queue a",
			\"queueToList":"Queue a -> [a]",
		\},
		\'Data.Ratio':{
		\},
		\'Data.STRef':{
			\"modifySTRef":"STRef s a -> (a -> a) -> ST s ()",
			\"newSTRef":"a -> ST s (STRef s a)",
			\"readSTRef":"STRef s a -> ST s a",
			\"writeSTRef":"STRef s a -> a -> ST s ()",
		\},
		\'Data.Set':{
			\"addToSet":"Ord a => Set a -> a -> Set a",
			\"cardinality":"Set a -> Int",
			\"delFromSet":"Ord a => Set a -> a -> Set a",
			\"delete":"Ord a => a -> Set a -> Set a",
			\"deleteFindMax":"Set a -> (a, Set a)",
			\"deleteFindMin":"Set a -> (a, Set a)",
			\"deleteMax":"Set a -> Set a",
			\"deleteMin":"Set a -> Set a",
			\"difference":"Ord a => Set a -> Set a -> Set a",
			\"elementOf":"Ord a => a -> Set a -> Bool",
			\"elems":"Set a -> [a]",
			\"empty":"Set a",
			\"emptySet":"Set a",
			\"filter":"Ord a => (a -> Bool) -> Set a -> Set a",
			\"findMax":"Set a -> a",
			\"findMin":"Set a -> a",
			\"fold":"(a -> b -> b) -> b -> Set a -> b",
			\"fromAscList":"Eq a => [a] -> Set a",
			\"fromDistinctAscList":"[a] -> Set a",
			\"fromList":"Ord a => [a] -> Set a",
			\"insert":"Ord a => a -> Set a -> Set a",
			\"intersect":"Ord a => Set a -> Set a -> Set a",
			\"intersection":"Ord a => Set a -> Set a -> Set a",
			\"isEmptySet":"Set a -> Bool",
			\"isProperSubsetOf":"Ord a => Set a -> Set a -> Bool",
			\"isSubsetOf":"Ord a => Set a -> Set a -> Bool",
			\"map":"(Ord a, Ord b) => (a -> b) -> Set a -> Set b",
			\"mapMonotonic":"(a -> b) -> Set a -> Set b",
			\"mapSet":"(Ord a, Ord b) => (b -> a) -> Set b -> Set a",
			\"member":"Ord a => a -> Set a -> Bool",
			\"minusSet":"Ord a => Set a -> Set a -> Set a",
			\"mkSet":"Ord a => [a] -> Set a",
			\"null":"Set a -> Bool",
			\"partition":"Ord a => (a -> Bool) -> Set a -> (Set a, Set a)",
			\"setToList":"Set a -> [a]",
			\"showTree":"Show a => Set a -> String",
			\"showTreeWith":"Show a => Bool -> Bool -> Set a -> String",
			\"singleton":"a -> Set a",
			\"size":"Set a -> Int",
			\"split":"Ord a => a -> Set a -> (Set a, Set a)",
			\"splitMember":"Ord a => a -> Set a -> (Set a, Bool, Set a)",
			\"toAscList":"Set a -> [a]",
			\"toList":"Set a -> [a]",
			\"union":"Ord a => Set a -> Set a -> Set a",
			\"unionManySets":"Ord a => [Set a] -> Set a",
			\"unions":"Ord a => [Set a] -> Set a",
			\"unitSet":"a -> Set a",
			\"valid":"Ord a => Set a -> Bool",
		\},
		\'Data.Tree':{
			\"drawForest":"Forest String -> String",
			\"drawTree":"Tree String -> String",
			\"flatten":"Tree a -> [a]",
			\"levels":"Tree a -> [[a]]",
			\"rootLabel":"Tree a -> a",
			\"subForest":"Tree a -> Forest a",
			\"unfoldForest":"(b -> (a, [b])) -> [b] -> Forest a",
			\"unfoldForestM":"Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)",
			\"unfoldForestM_BF":"Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)",
			\"unfoldTree":"(b -> (a, [b])) -> b -> Tree a",
			\"unfoldTreeM":"Monad m => (b -> m (a, [b])) -> b -> m (Tree a)",
			\"unfoldTreeM_BF":"Monad m => (b -> m (a, [b])) -> b -> m (Tree a)",
		\},
		\'Data.Typeable':{
			\"cast":"(Typeable a, Typeable b) => a -> Maybe b",
			\"funResultTy":"TypeRep -> TypeRep -> Maybe TypeRep",
			\"gcast":"(Typeable a, Typeable b) => c a -> Maybe (c b)",
			\"gcast1":"(Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))",
			\"gcast2":"(Typeable2 t, Typeable2 t') => c (t a b) -> Maybe (c (t' a b))",
			\"mkAppTy":"TypeRep -> TypeRep -> TypeRep",
			\"mkFunTy":"TypeRep -> TypeRep -> TypeRep",
			\"mkTyCon":"String -> TyCon",
			\"mkTyConApp":"TyCon -> [TypeRep] -> TypeRep",
			\"splitTyConApp":"TypeRep -> (TyCon, [TypeRep])",
			\"tyConString":"TyCon -> String",
			\"typeOf":"Typeable a => a -> TypeRep",
			\"typeOf1":"Typeable1 t => t a -> TypeRep",
			\"typeOf1Default":"(Typeable2 t, Typeable a) => t a b -> TypeRep",
			\"typeOf2":"Typeable2 t => t a b -> TypeRep",
			\"typeOf2Default":"(Typeable3 t, Typeable a) => t a b c -> TypeRep",
			\"typeOf3":"Typeable3 t => t a b c -> TypeRep",
			\"typeOf3Default":"(Typeable4 t, Typeable a) => t a b c d -> TypeRep",
			\"typeOf4":"Typeable4 t => t a b c d -> TypeRep",
			\"typeOf4Default":"(Typeable5 t, Typeable a) => t a b c d e -> TypeRep",
			\"typeOf5":"Typeable5 t => t a b c d e -> TypeRep",
			\"typeOf5Default":"(Typeable6 t, Typeable a) => t a b c d e f -> TypeRep",
			\"typeOf6":"Typeable6 t => t a b c d e f -> TypeRep",
			\"typeOf6Default":"(Typeable7 t, Typeable a) => t a b c d e f g -> TypeRep",
			\"typeOf7":"Typeable7 t => t a b c d e f g -> TypeRep",
			\"typeOfDefault":"(Typeable1 t, Typeable a) => t a -> TypeRep",
			\"typeRepArgs":"TypeRep -> [TypeRep]",
			\"typeRepTyCon":"TypeRep -> TyCon",
		\},
		\'Data.Unique':{
			\"hashUnique":"Unique -> Int",
			\"newUnique":"IO Unique",
		\},
		\'Data.Version':{
			\"parseVersion":"ReadP Version",
			\"showVersion":"Version -> String",
			\"versionBranch":"Version -> [Int]",
			\"versionTags":"Version -> [String]",
		\},
		\'Data.Word':{
		\},
		\'Debug.Trace':{
			\"putTraceMsg":"String -> IO ()",
			\"trace":"String -> a -> a",
		\},
		\'Directory':{
			\"createDirectory":"FilePath -> IO ()",
			\"doesDirectoryExist":"FilePath -> IO Bool",
			\"doesFileExist":"FilePath -> IO Bool",
			\"executable":"Permissions -> Bool",
			\"getCurrentDirectory":"IO FilePath",
			\"getDirectoryContents":"FilePath -> IO [FilePath]",
			\"getModificationTime":"FilePath -> IO ClockTime",
			\"getPermissions":"FilePath -> IO Permissions",
			\"readable":"Permissions -> Bool",
			\"removeDirectory":"FilePath -> IO ()",
			\"removeFile":"FilePath -> IO ()",
			\"renameDirectory":"FilePath -> FilePath -> IO ()",
			\"renameFile":"FilePath -> FilePath -> IO ()",
			\"searchable":"Permissions -> Bool",
			\"setCurrentDirectory":"FilePath -> IO ()",
			\"setPermissions":"FilePath -> Permissions -> IO ()",
			\"writable":"Permissions -> Bool",
		\},
		\'Distribution.Compat.Directory':{
		\},
		\'Distribution.Compat.Exception':{
		\},
		\'Distribution.Compat.FilePath':{
			\"breakFilePath":"FilePath -> [String]",
			\"changeFileExt":"FilePath -> String -> FilePath",
			\"commonParent":"[FilePath] -> Maybe FilePath",
			\"dllExtension":"String",
			\"dropAbsolutePrefix":"FilePath -> FilePath",
			\"dropPrefix":"FilePath -> FilePath -> FilePath",
			\"exeExtension":"String",
			\"isAbsolutePath":"FilePath -> Bool",
			\"isPathSeparator":"Char -> Bool",
			\"isRootedPath":"FilePath -> Bool",
			\"joinFileExt":"String -> String -> FilePath",
			\"joinFileName":"String -> String -> FilePath",
			\"joinPaths":"FilePath -> FilePath -> FilePath",
			\"mkSearchPath":"[FilePath] -> String",
			\"objExtension":"String",
			\"parseSearchPath":"String -> [FilePath]",
			\"pathParents":"FilePath -> [FilePath]",
			\"pathSeparator":"Char",
			\"searchPathSeparator":"Char",
			\"splitFileExt":"FilePath -> (String, String)",
			\"splitFileName":"FilePath -> (String, String)",
			\"splitFilePath":"FilePath -> (String, String, String)",
		\},
		\'Distribution.Extension':{
			\"extensionsToGHCFlag":"[Extension] -> ([Extension], [Opt])",
			\"extensionsToHugsFlag":"[Extension] -> ([Extension], [Opt])",
			\"extensionsToNHCFlag":"[Extension] -> ([Extension], [Opt])",
		\},
		\'Distribution.GetOpt':{
			\"getOpt":"ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])",
			\"getOpt'":"ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])",
			\"usageInfo":"String -> [OptDescr a] -> String",
		\},
		\'Distribution.InstalledPackageInfo':{
			\"author":"InstalledPackageInfo -> String",
			\"category":"InstalledPackageInfo -> String",
			\"ccOptions":"InstalledPackageInfo -> [Opt]",
			\"copyright":"InstalledPackageInfo -> String",
			\"depends":"InstalledPackageInfo -> [PackageIdentifier]",
			\"description":"InstalledPackageInfo -> String",
			\"emptyInstalledPackageInfo":"InstalledPackageInfo",
			\"exposed":"InstalledPackageInfo -> Bool",
			\"exposedModules":"InstalledPackageInfo -> [String]",
			\"extraLibraries":"InstalledPackageInfo -> [String]",
			\"frameworkDirs":"InstalledPackageInfo -> [FilePath]",
			\"frameworks":"InstalledPackageInfo -> [String]",
			\"haddockHTMLs":"InstalledPackageInfo -> [FilePath]",
			\"haddockInterfaces":"InstalledPackageInfo -> [FilePath]",
			\"hiddenModules":"InstalledPackageInfo -> [String]",
			\"homepage":"InstalledPackageInfo -> String",
			\"hsLibraries":"InstalledPackageInfo -> [String]",
			\"hugsOptions":"InstalledPackageInfo -> [Opt]",
			\"importDirs":"InstalledPackageInfo -> [FilePath]",
			\"includeDirs":"InstalledPackageInfo -> [FilePath]",
			\"includes":"InstalledPackageInfo -> [String]",
			\"ldOptions":"InstalledPackageInfo -> [Opt]",
			\"libraryDirs":"InstalledPackageInfo -> [FilePath]",
			\"license":"InstalledPackageInfo -> License",
			\"maintainer":"InstalledPackageInfo -> String",
			\"package":"InstalledPackageInfo -> PackageIdentifier",
			\"parseInstalledPackageInfo":"String -> ParseResult InstalledPackageInfo",
			\"pkgUrl":"InstalledPackageInfo -> String",
			\"showInstalledPackageInfo":"InstalledPackageInfo -> String",
			\"showInstalledPackageInfoField":"String -> Maybe (InstalledPackageInfo -> String)",
			\"stability":"InstalledPackageInfo -> String",
		\},
		\'Distribution.License':{
		\},
		\'Distribution.Package':{
			\"parsePackageId":"ReadP r PackageIdentifier",
			\"parsePackageName":"ReadP r String",
			\"pkgName":"PackageIdentifier -> String",
			\"pkgVersion":"PackageIdentifier -> Version",
			\"showPackageId":"PackageIdentifier -> String",
		\},
		\'Distribution.PackageDescription':{
			\"author":"PackageDescription -> String",
			\"basicStanzaFields":"[StanzaField PackageDescription]",
			\"buildDepends":"PackageDescription -> [Dependency]",
			\"buildInfo":"Executable -> BuildInfo",
			\"buildable":"BuildInfo -> Bool",
			\"cSources":"BuildInfo -> [FilePath]",
			\"category":"PackageDescription -> String",
			\"ccOptions":"BuildInfo -> [String]",
			\"copyright":"PackageDescription -> String",
			\"description":"PackageDescription -> String",
			\"emptyBuildInfo":"BuildInfo",
			\"emptyHookedBuildInfo":"HookedBuildInfo",
			\"emptyPackageDescription":"PackageDescription",
			\"errorOut":"[String] -> [String] -> IO ()",
			\"exeModules":"PackageDescription -> [String]",
			\"exeName":"Executable -> String",
			\"executables":"PackageDescription -> [Executable]",
			\"exposedModules":"Library -> [String]",
			\"extensions":"BuildInfo -> [Extension]",
			\"extraLibDirs":"BuildInfo -> [String]",
			\"extraLibs":"BuildInfo -> [String]",
			\"fieldGet":"StanzaField a -> a -> Doc",
			\"fieldName":"StanzaField a -> String",
			\"fieldSet":"StanzaField a -> LineNo -> String -> a -> ParseResult a",
			\"frameworks":"BuildInfo -> [String]",
			\"hasLibs":"PackageDescription -> Bool",
			\"hcOptions":"CompilerFlavor -> [(CompilerFlavor, [String])] -> [String]",
			\"homepage":"PackageDescription -> String",
			\"hsSourceDir":"BuildInfo -> FilePath",
			\"includeDirs":"BuildInfo -> [FilePath]",
			\"includes":"BuildInfo -> [FilePath]",
			\"ldOptions":"BuildInfo -> [String]",
			\"libBuildInfo":"Library -> BuildInfo",
			\"libModules":"PackageDescription -> [String]",
			\"library":"PackageDescription -> Maybe Library",
			\"license":"PackageDescription -> License",
			\"licenseFile":"PackageDescription -> FilePath",
			\"maintainer":"PackageDescription -> String",
			\"modulePath":"Executable -> FilePath",
			\"options":"BuildInfo -> [(CompilerFlavor,[String])]",
			\"otherModules":"BuildInfo -> [String]",
			\"package":"PackageDescription -> PackageIdentifier",
			\"parseDescription":"String -> ParseResult PackageDescription",
			\"parseHookedBuildInfo":"String -> ParseResult HookedBuildInfo",
			\"pkgUrl":"PackageDescription -> String",
			\"readHookedBuildInfo":"FilePath -> IO HookedBuildInfo",
			\"readPackageDescription":"FilePath -> IO PackageDescription",
			\"sanityCheckPackage":"PackageDescription -> IO ([String], [String])",
			\"setupMessage":"String -> PackageDescription -> IO ()",
			\"showError":"PError -> String",
			\"showHookedBuildInfo":"HookedBuildInfo -> String",
			\"showPackageDescription":"PackageDescription -> String",
			\"stability":"PackageDescription -> String",
			\"synopsis":"PackageDescription -> String",
			\"testedWith":"PackageDescription -> [(CompilerFlavor,VersionRange)]",
			\"updatePackageDescription":"HookedBuildInfo -> PackageDescription -> PackageDescription",
			\"withExe":"PackageDescription -> (Executable -> IO a) -> IO ()",
			\"withLib":"PackageDescription -> a -> (Library -> IO a) -> IO a",
			\"writeHookedBuildInfo":"FilePath -> HookedBuildInfo -> IO ()",
			\"writePackageDescription":"FilePath -> PackageDescription -> IO ()",
		\},
		\'Distribution.PreProcess':{
			\"knownSuffixHandlers":"[PPSuffixHandler]",
			\"ppAlex":"BuildInfo -> LocalBuildInfo -> PreProcessor",
			\"ppC2hs":"PreProcessor",
			\"ppCpp":"BuildInfo -> LocalBuildInfo -> PreProcessor",
			\"ppCpp'":"[String] -> BuildInfo -> LocalBuildInfo -> PreProcessor",
			\"ppGreenCard":"PreProcessor",
			\"ppHappy":"BuildInfo -> LocalBuildInfo -> PreProcessor",
			\"ppHsc2hs":"BuildInfo -> LocalBuildInfo -> PreProcessor",
			\"ppSuffixes":"[PPSuffixHandler] -> [String]",
			\"ppUnlit":"PreProcessor",
			\"preprocessSources":"PackageDescription -> LocalBuildInfo -> Int -> [PPSuffixHandler] -> IO ()",
			\"removePreprocessed":"FilePath -> [String] -> [String] -> IO ()",
			\"removePreprocessedPackage":"PackageDescription -> FilePath -> [String] -> IO ()",
		\},
		\'Distribution.PreProcess.Unlit':{
			\"plain":"String -> String -> String",
			\"unlit":"String -> String -> String",
		\},
		\'Distribution.Setup':{
			\"compilerFlavor":"Compiler -> CompilerFlavor",
			\"compilerPath":"Compiler -> FilePath",
			\"compilerPkgTool":"Compiler -> FilePath",
			\"compilerVersion":"Compiler -> Version",
			\"configAlex":"ConfigFlags -> Maybe FilePath",
			\"configCpphs":"ConfigFlags -> Maybe FilePath",
			\"configHaddock":"ConfigFlags -> Maybe FilePath",
			\"configHappy":"ConfigFlags -> Maybe FilePath",
			\"configHcFlavor":"ConfigFlags -> Maybe CompilerFlavor",
			\"configHcPath":"ConfigFlags -> Maybe FilePath",
			\"configHcPkg":"ConfigFlags -> Maybe FilePath",
			\"configHsc2hs":"ConfigFlags -> Maybe FilePath",
			\"configPrefix":"ConfigFlags -> Maybe FilePath",
			\"configUser":"ConfigFlags -> Bool",
			\"configVerbose":"ConfigFlags -> Int",
			\"parseBuildArgs":"[String] -> [OptDescr a] -> IO (Int, [a], [String])",
			\"parseCleanArgs":"[String] -> [OptDescr a] -> IO (Int, [a], [String])",
			\"parseConfigureArgs":"ConfigFlags -> [String] -> [OptDescr a] -> IO (ConfigFlags, [a], [String])",
			\"parseCopyArgs":"CopyFlags -> [String] -> [OptDescr a] -> IO (CopyFlags, [a], [String])",
			\"parseGlobalArgs":"[String] -> IO (Action, [String])",
			\"parseHaddockArgs":"[String] -> [OptDescr a] -> IO (Int, [a], [String])",
			\"parseInstallArgs":"InstallFlags -> [String] -> [OptDescr a] -> IO (InstallFlags, [a], [String])",
			\"parseProgramaticaArgs":"[String] -> [OptDescr a] -> IO (Int, [a], [String])",
			\"parseRegisterArgs":"RegisterFlags -> [String] -> [OptDescr a] -> IO (RegisterFlags, [a], [String])",
			\"parseSDistArgs":"[String] -> [OptDescr a] -> IO (Int, [a], [String])",
			\"parseUnregisterArgs":"RegisterFlags -> [String] -> [OptDescr a] -> IO (RegisterFlags, [a], [String])",
		\},
		\'Distribution.Simple':{
			\"defaultHookedPackageDesc":"IO (Maybe FilePath)",
			\"defaultMain":"IO ()",
			\"defaultMainNoRead":"PackageDescription -> IO ()",
			\"defaultMainWithHooks":"UserHooks -> IO ()",
			\"defaultUserHooks":"UserHooks",
			\"emptyUserHooks":"UserHooks",
			\"hookedPreProcessors":"UserHooks -> [PPSuffixHandler]",
			\"postBuild":"UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode",
			\"postClean":"UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode",
			\"postConf":"UserHooks -> Args -> ConfigFlags -> LocalBuildInfo -> IO ExitCode",
			\"postCopy":"UserHooks -> Args -> CopyFlags -> LocalBuildInfo -> IO ExitCode",
			\"postHaddock":"UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode",
			\"postInst":"UserHooks -> Args -> InstallFlags -> LocalBuildInfo -> IO ExitCode",
			\"postPFE":"UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode",
			\"postReg":"UserHooks -> Args -> RegisterFlags -> LocalBuildInfo -> IO ExitCode",
			\"postSDist":"UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode",
			\"postUnreg":"UserHooks -> Args -> RegisterFlags -> LocalBuildInfo -> IO ExitCode",
			\"preBuild":"UserHooks -> Args -> Int -> IO HookedBuildInfo",
			\"preClean":"UserHooks -> Args -> Int -> IO HookedBuildInfo",
			\"preConf":"UserHooks -> Args -> ConfigFlags -> IO HookedBuildInfo",
			\"preCopy":"UserHooks -> Args -> CopyFlags -> IO HookedBuildInfo",
			\"preHaddock":"UserHooks -> Args -> Int -> IO HookedBuildInfo",
			\"preInst":"UserHooks -> Args -> InstallFlags -> IO HookedBuildInfo",
			\"prePFE":"UserHooks -> Args -> Int -> IO HookedBuildInfo",
			\"preReg":"UserHooks -> Args -> RegisterFlags -> IO HookedBuildInfo",
			\"preSDist":"UserHooks -> Args -> Int -> IO HookedBuildInfo",
			\"preUnreg":"UserHooks -> Args -> RegisterFlags -> IO HookedBuildInfo",
			\"readDesc":"UserHooks -> (IO (Maybe PackageDescription))",
			\"runTests":"UserHooks -> Args -> Bool -> LocalBuildInfo -> IO ExitCode",
		\},
		\'Distribution.Simple.Build':{
			\"build":"PackageDescription -> LocalBuildInfo -> Int -> [PPSuffixHandler] -> IO ()",
		\},
		\'Distribution.Simple.Configure':{
			\"buildDir":"LocalBuildInfo -> FilePath",
			\"compiler":"LocalBuildInfo -> Compiler",
			\"configure":"PackageDescription -> ConfigFlags -> IO LocalBuildInfo",
			\"findProgram":"String -> Maybe FilePath -> IO (Maybe FilePath)",
			\"getPersistBuildConfig":"IO LocalBuildInfo",
			\"localBuildInfoFile":"FilePath",
			\"packageDeps":"LocalBuildInfo -> [PackageIdentifier]",
			\"prefix":"LocalBuildInfo -> FilePath",
			\"withAlex":"LocalBuildInfo -> Maybe FilePath",
			\"withCpphs":"LocalBuildInfo -> Maybe FilePath",
			\"withHaddock":"LocalBuildInfo -> Maybe FilePath",
			\"withHappy":"LocalBuildInfo -> Maybe FilePath",
			\"withHsc2hs":"LocalBuildInfo -> Maybe FilePath",
			\"writePersistBuildConfig":"LocalBuildInfo -> IO ()",
		\},
		\'Distribution.Simple.GHCPackageConfig':{
			\"auto":"GHCPackageConfig -> Bool",
			\"c_includes":"GHCPackageConfig -> [String]",
			\"canReadLocalPackageConfig":"IO Bool",
			\"canWriteLocalPackageConfig":"IO Bool",
			\"defaultGHCPackageConfig":"GHCPackageConfig",
			\"extra_cc_opts":"GHCPackageConfig -> [String]",
			\"extra_frameworks":"GHCPackageConfig -> [String]",
			\"extra_ghc_opts":"GHCPackageConfig -> [String]",
			\"extra_ld_opts":"GHCPackageConfig -> [String]",
			\"extra_libraries":"GHCPackageConfig -> [String]",
			\"framework_dirs":"GHCPackageConfig -> [String]",
			\"hs_libraries":"GHCPackageConfig -> [String]",
			\"import_dirs":"GHCPackageConfig -> [String]",
			\"include_dirs":"GHCPackageConfig -> [String]",
			\"library_dirs":"GHCPackageConfig -> [String]",
			\"localPackageConfig":"IO FilePath",
			\"maybeCreateLocalPackageConfig":"IO Bool",
			\"mkGHCPackageConfig":"PackageDescription -> LocalBuildInfo -> GHCPackageConfig",
			\"name":"GHCPackageConfig -> String",
			\"package_deps":"GHCPackageConfig -> [String]",
			\"showGHCPackageConfig":"GHCPackageConfig -> String",
			\"source_dirs":"GHCPackageConfig -> [String]",
		\},
		\'Distribution.Simple.Install':{
			\"hugsMainFilename":"Executable -> FilePath",
			\"hugsPackageDir":"PackageDescription -> LocalBuildInfo -> FilePath",
			\"hugsProgramsDirs":"PackageDescription -> LocalBuildInfo -> [FilePath]",
			\"install":"PackageDescription -> LocalBuildInfo -> (Maybe FilePath, Int) -> IO ()",
			\"mkBinDir":"PackageDescription -> LocalBuildInfo -> Maybe FilePath -> FilePath",
			\"mkLibDir":"PackageDescription -> LocalBuildInfo -> Maybe FilePath -> FilePath",
		\},
		\'Distribution.Simple.Register':{
			\"installedPkgConfigFile":"String",
			\"regScriptLocation":"FilePath",
			\"register":"PackageDescription -> LocalBuildInfo -> RegisterFlags -> IO ()",
			\"removeInstalledConfig":"IO ()",
			\"unregScriptLocation":"FilePath",
			\"unregister":"PackageDescription -> LocalBuildInfo -> RegisterFlags -> IO ()",
			\"writeInstalledConfig":"PackageDescription -> LocalBuildInfo -> IO ()",
		\},
		\'Distribution.Simple.SrcDist':{
			\"sdist":"FilePath -> FilePath -> Int -> [PPSuffixHandler] -> PackageDescription -> IO ()",
		\},
		\'Foreign':{
			\"unsafePerformIO":"IO a -> a",
		\},
		\'Foreign.C.Error':{
			\"e2BIG":"Errno",
			\"eACCES":"Errno",
			\"eADDRINUSE":"Errno",
			\"eADDRNOTAVAIL":"Errno",
			\"eADV":"Errno",
			\"eAFNOSUPPORT":"Errno",
			\"eAGAIN":"Errno",
			\"eALREADY":"Errno",
			\"eBADF":"Errno",
			\"eBADMSG":"Errno",
			\"eBADRPC":"Errno",
			\"eBUSY":"Errno",
			\"eCHILD":"Errno",
			\"eCOMM":"Errno",
			\"eCONNABORTED":"Errno",
			\"eCONNREFUSED":"Errno",
			\"eCONNRESET":"Errno",
			\"eDEADLK":"Errno",
			\"eDESTADDRREQ":"Errno",
			\"eDIRTY":"Errno",
			\"eDOM":"Errno",
			\"eDQUOT":"Errno",
			\"eEXIST":"Errno",
			\"eFAULT":"Errno",
			\"eFBIG":"Errno",
			\"eFTYPE":"Errno",
			\"eHOSTDOWN":"Errno",
			\"eHOSTUNREACH":"Errno",
			\"eIDRM":"Errno",
			\"eILSEQ":"Errno",
			\"eINPROGRESS":"Errno",
			\"eINTR":"Errno",
			\"eINVAL":"Errno",
			\"eIO":"Errno",
			\"eISCONN":"Errno",
			\"eISDIR":"Errno",
			\"eLOOP":"Errno",
			\"eMFILE":"Errno",
			\"eMLINK":"Errno",
			\"eMSGSIZE":"Errno",
			\"eMULTIHOP":"Errno",
			\"eNAMETOOLONG":"Errno",
			\"eNETDOWN":"Errno",
			\"eNETRESET":"Errno",
			\"eNETUNREACH":"Errno",
			\"eNFILE":"Errno",
			\"eNOBUFS":"Errno",
			\"eNODATA":"Errno",
			\"eNODEV":"Errno",
			\"eNOENT":"Errno",
			\"eNOEXEC":"Errno",
			\"eNOLCK":"Errno",
			\"eNOLINK":"Errno",
			\"eNOMEM":"Errno",
			\"eNOMSG":"Errno",
			\"eNONET":"Errno",
			\"eNOPROTOOPT":"Errno",
			\"eNOSPC":"Errno",
			\"eNOSR":"Errno",
			\"eNOSTR":"Errno",
			\"eNOSYS":"Errno",
			\"eNOTBLK":"Errno",
			\"eNOTCONN":"Errno",
			\"eNOTDIR":"Errno",
			\"eNOTEMPTY":"Errno",
			\"eNOTSOCK":"Errno",
			\"eNOTTY":"Errno",
			\"eNXIO":"Errno",
			\"eOK":"Errno",
			\"eOPNOTSUPP":"Errno",
			\"ePERM":"Errno",
			\"ePFNOSUPPORT":"Errno",
			\"ePIPE":"Errno",
			\"ePROCLIM":"Errno",
			\"ePROCUNAVAIL":"Errno",
			\"ePROGMISMATCH":"Errno",
			\"ePROGUNAVAIL":"Errno",
			\"ePROTO":"Errno",
			\"ePROTONOSUPPORT":"Errno",
			\"ePROTOTYPE":"Errno",
			\"eRANGE":"Errno",
			\"eREMCHG":"Errno",
			\"eREMOTE":"Errno",
			\"eROFS":"Errno",
			\"eRPCMISMATCH":"Errno",
			\"eRREMOTE":"Errno",
			\"eSHUTDOWN":"Errno",
			\"eSOCKTNOSUPPORT":"Errno",
			\"eSPIPE":"Errno",
			\"eSRCH":"Errno",
			\"eSRMNT":"Errno",
			\"eSTALE":"Errno",
			\"eTIME":"Errno",
			\"eTIMEDOUT":"Errno",
			\"eTOOMANYREFS":"Errno",
			\"eTXTBSY":"Errno",
			\"eUSERS":"Errno",
			\"eWOULDBLOCK":"Errno",
			\"eXDEV":"Errno",
			\"errnoToIOError":"String -> Errno -> Maybe Handle -> Maybe String -> IOError",
			\"getErrno":"IO Errno",
			\"isValidErrno":"Errno -> Bool",
			\"resetErrno":"IO ()",
			\"throwErrno":"String -> IO a",
			\"throwErrnoIf":"(a -> Bool) -> String -> IO a -> IO a",
			\"throwErrnoIfMinus1":"Num a => String -> IO a -> IO a",
			\"throwErrnoIfMinus1Retry":"Num a => String -> IO a -> IO a",
			\"throwErrnoIfMinus1RetryMayBlock":"Num a => String -> IO a -> IO b -> IO a",
			\"throwErrnoIfMinus1RetryMayBlock_":"Num a => String -> IO a -> IO b -> IO ()",
			\"throwErrnoIfMinus1Retry_":"Num a => String -> IO a -> IO ()",
			\"throwErrnoIfMinus1_":"Num a => String -> IO a -> IO ()",
			\"throwErrnoIfNull":"String -> IO (Ptr a) -> IO (Ptr a)",
			\"throwErrnoIfNullRetry":"String -> IO (Ptr a) -> IO (Ptr a)",
			\"throwErrnoIfNullRetryMayBlock":"String -> IO (Ptr a) -> IO b -> IO (Ptr a)",
			\"throwErrnoIfRetry":"(a -> Bool) -> String -> IO a -> IO a",
			\"throwErrnoIfRetryMayBlock":"(a -> Bool) -> String -> IO a -> IO b -> IO a",
			\"throwErrnoIfRetryMayBlock_":"(a -> Bool) -> String -> IO a -> IO b -> IO ()",
			\"throwErrnoIfRetry_":"(a -> Bool) -> String -> IO a -> IO ()",
			\"throwErrnoIf_":"(a -> Bool) -> String -> IO a -> IO ()",
		\},
		\'Foreign.C.String':{
			\"castCCharToChar":"CChar -> Char",
			\"castCharToCChar":"Char -> CChar",
			\"charIsRepresentable":"Char -> IO Bool",
			\"newCAString":"String -> IO CString",
			\"newCAStringLen":"String -> IO CStringLen",
			\"newCString":"String -> IO CString",
			\"newCStringLen":"String -> IO CStringLen",
			\"newCWString":"String -> IO CWString",
			\"newCWStringLen":"String -> IO CWStringLen",
			\"peekCAString":"CString -> IO String",
			\"peekCAStringLen":"CStringLen -> IO String",
			\"peekCString":"CString -> IO String",
			\"peekCStringLen":"CStringLen -> IO String",
			\"peekCWString":"CWString -> IO String",
			\"peekCWStringLen":"CWStringLen -> IO String",
			\"withCAString":"String -> (CString -> IO a) -> IO a",
			\"withCAStringLen":"String -> (CStringLen -> IO a) -> IO a",
			\"withCString":"String -> (CString -> IO a) -> IO a",
			\"withCStringLen":"String -> (CStringLen -> IO a) -> IO a",
			\"withCWString":"String -> (CWString -> IO a) -> IO a",
			\"withCWStringLen":"String -> (CWStringLen -> IO a) -> IO a",
		\},
		\'Foreign.C.Types':{
		\},
		\'Foreign.Concurrent':{
			\"addForeignPtrFinalizer":"ForeignPtr a -> IO () -> IO ()",
			\"newForeignPtr":"Ptr a -> IO () -> IO (ForeignPtr a)",
		\},
		\'Foreign.ForeignPtr':{
			\"addForeignPtrFinalizer":"FinalizerPtr a -> ForeignPtr a -> IO ()",
			\"castForeignPtr":"ForeignPtr a -> ForeignPtr b",
			\"finalizeForeignPtr":"ForeignPtr a -> IO ()",
			\"mallocForeignPtr":"Storable a => IO (ForeignPtr a)",
			\"mallocForeignPtrArray":"Storable a => Int -> IO (ForeignPtr a)",
			\"mallocForeignPtrArray0":"Storable a => Int -> IO (ForeignPtr a)",
			\"mallocForeignPtrBytes":"Int -> IO (ForeignPtr a)",
			\"newForeignPtr":"FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)",
			\"newForeignPtr_":"Ptr a -> IO (ForeignPtr a)",
			\"touchForeignPtr":"ForeignPtr a -> IO ()",
			\"unsafeForeignPtrToPtr":"ForeignPtr a -> Ptr a",
			\"withForeignPtr":"ForeignPtr a -> (Ptr a -> IO b) -> IO b",
		\},
		\'Foreign.Marshal.Alloc':{
			\"alloca":"Storable a => (Ptr a -> IO b) -> IO b",
			\"allocaBytes":"Int -> (Ptr a -> IO b) -> IO b",
			\"finalizerFree":"FinalizerPtr a",
			\"free":"Ptr a -> IO ()",
			\"malloc":"Storable a => IO (Ptr a)",
			\"mallocBytes":"Int -> IO (Ptr a)",
			\"realloc":"Storable b => Ptr a -> IO (Ptr b)",
			\"reallocBytes":"Ptr a -> Int -> IO (Ptr a)",
		\},
		\'Foreign.Marshal.Array':{
			\"advancePtr":"Storable a => Ptr a -> Int -> Ptr a",
			\"allocaArray":"Storable a => Int -> (Ptr a -> IO b) -> IO b",
			\"allocaArray0":"Storable a => Int -> (Ptr a -> IO b) -> IO b",
			\"copyArray":"Storable a => Ptr a -> Ptr a -> Int -> IO ()",
			\"lengthArray0":"(Storable a, Eq a) => a -> Ptr a -> IO Int",
			\"mallocArray":"Storable a => Int -> IO (Ptr a)",
			\"mallocArray0":"Storable a => Int -> IO (Ptr a)",
			\"moveArray":"Storable a => Ptr a -> Ptr a -> Int -> IO ()",
			\"newArray":"Storable a => [a] -> IO (Ptr a)",
			\"newArray0":"Storable a => a -> [a] -> IO (Ptr a)",
			\"peekArray":"Storable a => Int -> Ptr a -> IO [a]",
			\"peekArray0":"(Storable a, Eq a) => a -> Ptr a -> IO [a]",
			\"pokeArray":"Storable a => Ptr a -> [a] -> IO ()",
			\"pokeArray0":"Storable a => a -> Ptr a -> [a] -> IO ()",
			\"reallocArray":"Storable a => Ptr a -> Int -> IO (Ptr a)",
			\"reallocArray0":"Storable a => Ptr a -> Int -> IO (Ptr a)",
			\"withArray":"Storable a => [a] -> (Ptr a -> IO b) -> IO b",
			\"withArray0":"Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b",
			\"withArrayLen":"Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b",
			\"withArrayLen0":"Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b",
		\},
		\'Foreign.Marshal.Error':{
			\"throwIf":"(a -> Bool) -> (a -> String) -> IO a -> IO a",
			\"throwIfNeg":"(Ord a, Num a) => (a -> String) -> IO a -> IO a",
			\"throwIfNeg_":"(Ord a, Num a) => (a -> String) -> IO a -> IO ()",
			\"throwIfNull":"String -> IO (Ptr a) -> IO (Ptr a)",
			\"throwIf_":"(a -> Bool) -> (a -> String) -> IO a -> IO ()",
			\"void":"IO a -> IO ()",
		\},
		\'Foreign.Marshal.Pool':{
			\"freePool":"Pool -> IO ()",
			\"newPool":"IO Pool",
			\"pooledMalloc":"Storable a => Pool -> IO (Ptr a)",
			\"pooledMallocArray":"Storable a => Pool -> Int -> IO (Ptr a)",
			\"pooledMallocArray0":"Storable a => Pool -> Int -> IO (Ptr a)",
			\"pooledMallocBytes":"Pool -> Int -> IO (Ptr a)",
			\"pooledNew":"Storable a => Pool -> a -> IO (Ptr a)",
			\"pooledNewArray":"Storable a => Pool -> [a] -> IO (Ptr a)",
			\"pooledNewArray0":"Storable a => Pool -> a -> [a] -> IO (Ptr a)",
			\"pooledRealloc":"Storable a => Pool -> Ptr a -> IO (Ptr a)",
			\"pooledReallocArray":"Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)",
			\"pooledReallocArray0":"Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)",
			\"pooledReallocBytes":"Pool -> Ptr a -> Int -> IO (Ptr a)",
			\"withPool":"(Pool -> IO b) -> IO b",
		\},
		\'Foreign.Marshal.Utils':{
			\"copyBytes":"Ptr a -> Ptr a -> Int -> IO ()",
			\"fromBool":"Num a => Bool -> a",
			\"maybeNew":"(a -> IO (Ptr a)) -> Maybe a -> IO (Ptr a)",
			\"maybePeek":"(Ptr a -> IO b) -> Ptr a -> IO (Maybe b)",
			\"maybeWith":"(a -> (Ptr b -> IO c) -> IO c) -> Maybe a -> (Ptr b -> IO c) -> IO c",
			\"moveBytes":"Ptr a -> Ptr a -> Int -> IO ()",
			\"new":"Storable a => a -> IO (Ptr a)",
			\"toBool":"Num a => a -> Bool",
			\"with":"Storable a => a -> (Ptr a -> IO b) -> IO b",
			\"withMany":"(a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res",
			\"withObject":"Storable a => a -> (Ptr a -> IO b) -> IO b",
		\},
		\'Foreign.Ptr':{
			\"alignPtr":"Ptr a -> Int -> Ptr a",
			\"castFunPtr":"FunPtr a -> FunPtr b",
			\"castFunPtrToPtr":"FunPtr a -> Ptr b",
			\"castPtr":"Ptr a -> Ptr b",
			\"castPtrToFunPtr":"Ptr a -> FunPtr b",
			\"freeHaskellFunPtr":"FunPtr a -> IO ()",
			\"minusPtr":"Ptr a -> Ptr b -> Int",
			\"nullFunPtr":"FunPtr a",
			\"nullPtr":"Ptr a",
			\"plusPtr":"Ptr a -> Int -> Ptr b",
		\},
		\'Foreign.StablePtr':{
			\"castPtrToStablePtr":"Ptr () -> StablePtr a",
			\"castStablePtrToPtr":"StablePtr a -> Ptr ()",
			\"deRefStablePtr":"StablePtr a -> IO a",
			\"freeStablePtr":"StablePtr a -> IO ()",
			\"newStablePtr":"a -> IO (StablePtr a)",
		\},
		\'Foreign.Storable':{
			\"alignment":"Storable a => a -> Int",
			\"peek":"Storable a => Ptr a -> IO a",
			\"peekByteOff":"Storable a => Ptr b -> Int -> IO a",
			\"peekElemOff":"Storable a => Ptr a -> Int -> IO a",
			\"poke":"Storable a => Ptr a -> a -> IO ()",
			\"pokeByteOff":"Storable a => Ptr b -> Int -> a -> IO ()",
			\"pokeElemOff":"Storable a => Ptr a -> Int -> a -> IO ()",
			\"sizeOf":"Storable a => a -> Int",
		\},
		\'GHC.Conc':{
			\"addMVarFinalizer":"MVar a -> IO () -> IO ()",
			\"asyncDoProc":"FunPtr (Ptr a -> IO Int) -> Ptr a -> IO Int",
			\"asyncRead":"Int -> Int -> Int -> Ptr a -> IO (Int, Int)",
			\"asyncReadBA":"Int -> Int -> Int -> Int -> MutableByteArray# RealWorld -> IO (Int, Int)",
			\"asyncWrite":"Int -> Int -> Int -> Ptr a -> IO (Int, Int)",
			\"asyncWriteBA":"Int -> Int -> Int -> Int -> MutableByteArray# RealWorld -> IO (Int, Int)",
			\"atomically":"STM a -> IO a",
			\"catchSTM":"STM a -> (Exception -> STM a) -> STM a",
			\"isEmptyMVar":"MVar a -> IO Bool",
			\"labelThread":"ThreadId -> String -> IO ()",
			\"newEmptyMVar":"IO (MVar a)",
			\"newMVar":"a -> IO (MVar a)",
			\"newTVar":"a -> STM (TVar a)",
			\"orElse":"STM a -> STM a -> STM a",
			\"pseq":"a -> b -> b",
			\"putMVar":"MVar a -> a -> IO ()",
			\"readTVar":"TVar a -> STM a",
			\"retry":"STM a",
			\"takeMVar":"MVar a -> IO a",
			\"tryPutMVar":"MVar a -> a -> IO Bool",
			\"tryTakeMVar":"MVar a -> IO (Maybe a)",
			\"unsafeIOToSTM":"IO a -> STM a",
			\"writeTVar":"TVar a -> a -> STM ()",
		\},
		\'GHC.ConsoleHandler':{
			\"flushConsole":"Handle -> IO ()",
			\"installHandler":"Handler -> IO Handler",
		\},
		\'GHC.Dotnet':{
			\"checkResult":"(State# RealWorld -> (#State# RealWorld, a, Addr##)) -> IO a",
			\"marshalObject":"Object a -> (Addr# -> IO b) -> IO b",
			\"marshalString":"String -> (Addr# -> IO a) -> IO a",
			\"unmarshalObject":"Addr# -> Object a",
			\"unmarshalString":"Addr# -> String",
		\},
		\'GHC.Exts':{
			\"augment":"((a -> b -> b) -> b -> b) -> [a] -> [a]",
			\"build":"((a -> b -> b) -> b -> b) -> [a]",
			\"iShiftL#":"Int# -> Int# -> Int#",
			\"iShiftRA#":"Int# -> Int# -> Int#",
			\"iShiftRL#":"Int# -> Int# -> Int#",
			\"shiftL#":"Word# -> Int# -> Word#",
			\"shiftRL#":"Word# -> Int# -> Word#",
			\"split":"Splittable t => t -> (t,t)",
		\},
		\'GHC.Unicode':{
			\"isAsciiLower":"Char -> Bool",
			\"isAsciiUpper":"Char -> Bool",
		\},
		\'IO':{
			\"bracket":"IO a -> (a -> IO b) -> (a -> IO c) -> IO c",
			\"bracket_":"IO a -> (a -> IO b) -> IO c -> IO c",
			\"hClose":"Handle -> IO ()",
			\"hFileSize":"Handle -> IO Integer",
			\"hFlush":"Handle -> IO ()",
			\"hGetBuffering":"Handle -> IO BufferMode",
			\"hGetChar":"Handle -> IO Char",
			\"hGetContents":"Handle -> IO String",
			\"hGetLine":"Handle -> IO String",
			\"hGetPosn":"Handle -> IO HandlePosn",
			\"hIsClosed":"Handle -> IO Bool",
			\"hIsEOF":"Handle -> IO Bool",
			\"hIsOpen":"Handle -> IO Bool",
			\"hIsReadable":"Handle -> IO Bool",
			\"hIsSeekable":"Handle -> IO Bool",
			\"hIsWritable":"Handle -> IO Bool",
			\"hLookAhead":"Handle -> IO Char",
			\"hPrint":"Show a => Handle -> a -> IO ()",
			\"hPutChar":"Handle -> Char -> IO ()",
			\"hPutStr":"Handle -> String -> IO ()",
			\"hPutStrLn":"Handle -> String -> IO ()",
			\"hReady":"Handle -> IO Bool",
			\"hSeek":"Handle -> SeekMode -> Integer -> IO ()",
			\"hSetBuffering":"Handle -> BufferMode -> IO ()",
			\"hSetPosn":"HandlePosn -> IO ()",
			\"hWaitForInput":"Handle -> Int -> IO Bool",
			\"ioeGetErrorString":"IOError -> String",
			\"ioeGetFileName":"IOError -> Maybe FilePath",
			\"ioeGetHandle":"IOError -> Maybe Handle",
			\"isAlreadyExistsError":"IOError -> Bool",
			\"isAlreadyInUseError":"IOError -> Bool",
			\"isDoesNotExistError":"IOError -> Bool",
			\"isEOF":"IO Bool",
			\"isEOFError":"IOError -> Bool",
			\"isFullError":"IOError -> Bool",
			\"isIllegalOperation":"IOError -> Bool",
			\"isPermissionError":"IOError -> Bool",
			\"isUserError":"IOError -> Bool",
			\"openFile":"FilePath -> IOMode -> IO Handle",
			\"stderr":"Handle",
			\"stdin":"Handle",
			\"stdout":"Handle",
			\"try":"IO a -> IO (Either IOError a)",
		\},
		\'Ix':{
			\"inRange":"Ix a => (a,a) -> a -> Bool",
			\"index":"Ix a => (a,a) -> a -> Int",
			\"range":"Ix a => (a,a) -> [a]",
			\"rangeSize":"Ix a => (a,a) -> Int",
		\},
		\'Language.Haskell.Parser':{
			\"defaultParseMode":"ParseMode",
			\"parseFilename":"ParseMode -> String",
			\"parseModule":"String -> ParseResult HsModule",
			\"parseModuleWithMode":"ParseMode -> String -> ParseResult HsModule",
		\},
		\'Language.Haskell.Syntax':{
			\"as_name":"HsName",
			\"fun_tycon":"HsType",
			\"fun_tycon_name":"HsQName",
			\"hiding_name":"HsName",
			\"importAs":"HsImportDecl -> Maybe Module",
			\"importLoc":"HsImportDecl -> SrcLoc",
			\"importModule":"HsImportDecl -> Module",
			\"importQualified":"HsImportDecl -> Bool",
			\"importSpecs":"HsImportDecl -> (Maybe (Bool,[HsImportSpec]))",
			\"list_cons_name":"HsQName",
			\"list_tycon":"HsType",
			\"list_tycon_name":"HsQName",
			\"main_mod":"Module",
			\"main_name":"HsName",
			\"minus_name":"HsName",
			\"pling_name":"HsName",
			\"prelude_mod":"Module",
			\"qualified_name":"HsName",
			\"srcColumn":"SrcLoc -> Int",
			\"srcFilename":"SrcLoc -> String",
			\"srcLine":"SrcLoc -> Int",
			\"tuple_con":"Int -> HsExp",
			\"tuple_con_name":"Int -> HsQName",
			\"tuple_tycon":"Int -> HsType",
			\"tuple_tycon_name":"Int -> HsQName",
			\"unit_con":"HsExp",
			\"unit_con_name":"HsQName",
			\"unit_tycon":"HsType",
			\"unit_tycon_name":"HsQName",
		\},
		\'Language.Haskell.TH':{
			\"appE":"ExpQ -> ExpQ -> ExpQ",
			\"appT":"TypeQ -> TypeQ -> TypeQ",
			\"appsE":"[ExpQ] -> ExpQ",
			\"arithSeqE":"RangeQ -> ExpQ",
			\"arrowT":"TypeQ",
			\"asP":"Name -> PatQ -> PatQ",
			\"bindS":"PatQ -> ExpQ -> StmtQ",
			\"cCall":"Callconv",
			\"caseE":"ExpQ -> [MatchQ] -> ExpQ",
			\"charL":"Char -> Lit",
			\"classD":"CxtQ -> Name -> [Name] -> [FunDep] -> [DecQ] -> DecQ",
			\"clause":"[PatQ] -> BodyQ -> [DecQ] -> ClauseQ",
			\"compE":"[StmtQ] -> ExpQ",
			\"conE":"Name -> ExpQ",
			\"conP":"Name -> [PatQ] -> PatQ",
			\"conT":"Name -> TypeQ",
			\"condE":"ExpQ -> ExpQ -> ExpQ -> ExpQ",
			\"currentModule":"Q String",
			\"cxt":"[TypeQ] -> CxtQ",
			\"dataD":"CxtQ -> Name -> [Name] -> [ConQ] -> [Name] -> DecQ",
			\"defaultFixity":"Fixity",
			\"doE":"[StmtQ] -> ExpQ",
			\"doublePrimL":"Rational -> Lit",
			\"dyn":"String -> Q Exp",
			\"fieldExp":"Name -> ExpQ -> Q (Name, Exp)",
			\"fieldPat":"Name -> PatQ -> FieldPatQ",
			\"floatPrimL":"Rational -> Lit",
			\"forImpD":"Callconv -> Safety -> String -> Name -> TypeQ -> DecQ",
			\"forallT":"[Name] -> CxtQ -> TypeQ -> TypeQ",
			\"fromE":"ExpQ -> ExpQ",
			\"fromR":"ExpQ -> RangeQ",
			\"fromThenE":"ExpQ -> ExpQ -> ExpQ",
			\"fromThenR":"ExpQ -> ExpQ -> RangeQ",
			\"fromThenToE":"ExpQ -> ExpQ -> ExpQ -> ExpQ",
			\"fromThenToR":"ExpQ -> ExpQ -> ExpQ -> RangeQ",
			\"fromToE":"ExpQ -> ExpQ -> ExpQ",
			\"fromToR":"ExpQ -> ExpQ -> RangeQ",
			\"funD":"Name -> [ClauseQ] -> DecQ",
			\"global":"Name -> ExpQ",
			\"guardedB":"[Q (Guard, Exp)] -> BodyQ",
			\"infixApp":"ExpQ -> ExpQ -> ExpQ -> ExpQ",
			\"infixC":"Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ",
			\"infixE":"Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ",
			\"infixP":"PatQ -> Name -> PatQ -> PatQ",
			\"instanceD":"CxtQ -> TypeQ -> [DecQ] -> DecQ",
			\"intPrimL":"Integer -> Lit",
			\"integerL":"Integer -> Lit",
			\"isStrict":"Q Strict",
			\"lam1E":"PatQ -> ExpQ -> ExpQ",
			\"lamE":"[PatQ] -> ExpQ -> ExpQ",
			\"letE":"[DecQ] -> ExpQ -> ExpQ",
			\"letS":"[DecQ] -> StmtQ",
			\"listE":"[ExpQ] -> ExpQ",
			\"listP":"[PatQ] -> PatQ",
			\"listT":"TypeQ",
			\"litE":"Lit -> ExpQ",
			\"litP":"Lit -> PatQ",
			\"match":"PatQ -> BodyQ -> [DecQ] -> MatchQ",
			\"maxPrecedence":"Int",
			\"mkName":"String -> Name",
			\"nameBase":"Name -> String",
			\"nameModule":"Name -> Maybe String",
			\"newName":"String -> Q Name",
			\"newtypeD":"CxtQ -> Name -> [Name] -> ConQ -> [Name] -> DecQ",
			\"noBindS":"ExpQ -> StmtQ",
			\"normalB":"ExpQ -> BodyQ",
			\"normalC":"Name -> [StrictTypeQ] -> ConQ",
			\"normalG":"ExpQ -> GuardQ",
			\"normalGE":"ExpQ -> ExpQ -> Q (Guard, Exp)",
			\"notStrict":"Q Strict",
			\"parS":"[[StmtQ]] -> StmtQ",
			\"patG":"[StmtQ] -> GuardQ",
			\"patGE":"[StmtQ] -> Q (Guard, Exp)",
			\"ppr":"Ppr a => a -> Doc",
			\"pprExp":"Precedence -> Exp -> Doc",
			\"pprLit":"Precedence -> Lit -> Doc",
			\"pprParendType":"Type -> Doc",
			\"pprPat":"Precedence -> Pat -> Doc",
			\"ppr_list":"Ppr a => [a] -> Doc",
			\"pprint":"Ppr a => a -> String",
			\"rationalL":"Rational -> Lit",
			\"recC":"Name -> [VarStrictTypeQ] -> ConQ",
			\"recConE":"Name -> [Q (Name, Exp)] -> ExpQ",
			\"recP":"Name -> [FieldPatQ] -> PatQ",
			\"recUpdE":"ExpQ -> [Q (Name, Exp)] -> ExpQ",
			\"recover":"Q a -> Q a -> Q a",
			\"reify":"Name -> Q Info",
			\"report":"Bool -> String -> Q ()",
			\"runIO":"IO a -> Q a",
			\"runQ":"Quasi m => Q a -> m a",
			\"safe":"Safety",
			\"sectionL":"ExpQ -> ExpQ -> ExpQ",
			\"sectionR":"ExpQ -> ExpQ -> ExpQ",
			\"sigD":"Name -> TypeQ -> DecQ",
			\"sigE":"ExpQ -> TypeQ -> ExpQ",
			\"sigP":"PatQ -> TypeQ -> PatQ",
			\"stdCall":"Callconv",
			\"strictType":"Q Strict -> TypeQ -> StrictTypeQ",
			\"stringE":"String -> ExpQ",
			\"stringL":"String -> Lit",
			\"threadsafe":"Safety",
			\"tildeP":"PatQ -> PatQ",
			\"tupE":"[ExpQ] -> ExpQ",
			\"tupP":"[PatQ] -> PatQ",
			\"tupleDataName":"Int -> Name",
			\"tupleT":"Int -> TypeQ",
			\"tupleTypeName":"Int -> Name",
			\"tySynD":"Name -> [Name] -> TypeQ -> DecQ",
			\"unsafe":"Safety",
			\"valD":"PatQ -> BodyQ -> [DecQ] -> DecQ",
			\"varE":"Name -> ExpQ",
			\"varP":"Name -> PatQ",
			\"varStrictType":"Name -> StrictTypeQ -> VarStrictTypeQ",
			\"varT":"Name -> TypeQ",
			\"wildP":"PatQ",
		\},
		\'Language.Haskell.TH.Lib':{
			\"alpha":"[(Name, Name)] -> Name -> ExpQ",
			\"combine":"[([(Name, Name)], Pat)] -> ([(Name, Name)], [Pat])",
			\"forallC":"[Name] -> CxtQ -> ConQ -> ConQ",
			\"funDep":"[Name] -> [Name] -> FunDep",
			\"genpat":"Pat -> Q (Name -> ExpQ, Pat)",
			\"rename":"Pat -> Q ([(Name, Name)], Pat)",
			\"simpleMatch":"Pat -> Exp -> Match",
		\},
		\'Language.Haskell.TH.Ppr':{
			\"appPrec":"Precedence",
			\"nestDepth":"Int",
			\"noPrec":"Precedence",
			\"opPrec":"Precedence",
			\"parensIf":"Bool -> Doc -> Doc",
			\"pprBody":"Bool -> Body -> Doc",
			\"pprCxt":"Cxt -> Doc",
			\"pprFields":"[(Name, Exp)] -> Doc",
			\"pprFixity":"Name -> Fixity -> Doc",
			\"pprMaybeExp":"Precedence -> Maybe Exp -> Doc",
			\"pprStrictType":"(Strict, Type) -> Doc",
			\"pprTyApp":"(Type, [Type]) -> Doc",
			\"pprVarStrictType":"(Name, Strict, Type) -> Doc",
			\"showtextl":"Show a => a -> Doc",
			\"split":"Type -> (Type, [Type])",
			\"where_clause":"[Dec] -> Doc",
		\},
		\'Language.Haskell.TH.PprLib':{
			\"isEmpty":"Doc -> PprM Bool",
			\"pprName":"Name -> Doc",
			\"to_HPJ_Doc":"Doc -> Doc",
		\},
		\'Language.Haskell.TH.Syntax':{
			\"bindQ":"Q a -> (a -> Q b) -> Q b",
			\"lift":"Lift t => t -> Q Exp",
			\"mkModName":"String -> ModName",
			\"mkNameG_d":"String -> String -> Name",
			\"mkNameG_tc":"String -> String -> Name",
			\"mkNameG_v":"String -> String -> Name",
			\"mkNameL":"String -> Uniq -> Name",
			\"mkNameU":"String -> Uniq -> Name",
			\"mkOccName":"String -> OccName",
			\"modString":"ModName -> String",
			\"occString":"OccName -> String",
			\"qCurrentModule":"Quasi m => m String",
			\"qNewName":"Quasi m => String -> m Name",
			\"qRecover":"Quasi m => m a -> m a -> m a",
			\"qReify":"Quasi m => Name -> m Info",
			\"qReport":"Quasi m => Bool -> String -> m ()",
			\"qRunIO":"Quasi m => IO a -> m a",
			\"returnQ":"a -> Q a",
			\"sequenceQ":"[Q a] -> Q [a]",
		\},
		\'List':{
			\"delete":"Eq a => a -> [a] -> [a]",
			\"deleteBy":"(a -> a -> Bool) -> a -> [a] -> [a]",
			\"elemIndex":"Eq => a -> [a] -> Maybe Int",
			\"elemIndices":"Eq a => a -> [a] -> [Int]",
			\"find":"(a -> Bool) -> [a] -> Maybe a",
			\"findIndex":"(a -> Bool) -> [a] -> Maybe Int",
			\"findIndices":"(a -> Bool) -> [a] -> [Int]",
			\"genericDrop":"Integral a => a -> [b] -> [b]",
			\"genericIndex":"Integral a => [b] -> a -> b",
			\"genericLength":"Integral a => [b] -> a",
			\"genericReplicate":"Integral a => a -> b -> [b]",
			\"genericSplitAt":"Integral a => a -> [b] -> ([b],[b])",
			\"genericTake":"Integral a => a -> [b] -> [b]",
			\"group":"Eq a => [a] -> [[a]]",
			\"groupBy":"(a -> a -> Bool) -> [a] -> [[a]]",
			\"inits":"[a] -> [[a]]",
			\"insert":"Ord a => a -> [a] -> [a]",
			\"insertBy":"(a -> a -> Ordering) -> a -> [a] -> [a]",
			\"intersect":"Eq a => [a] -> [a] -> [a]",
			\"intersectBy":"(a -> a -> Bool) -> [a] -> [a] -> [a]",
			\"intersperse":"a -> [a] -> [a]",
			\"isPrefixOf":"Eq a => [a] -> [a] -> Bool",
			\"isSuffixOf":"Eq a => [a] -> [a] -> Bool",
			\"mapAccumL":"(a -> b -> (a,c)) -> a -> [b] -> (a,[c])",
			\"mapAccumR":"(a -> b -> (a,c)) -> a -> [b] -> (a,[c])",
			\"maximumBy":"(a -> a -> a) -> [a] -> a",
			\"minimumBy":"(a -> a -> a) -> [a] -> a",
			\"nub":"Eq a => [a] -> [a]",
			\"nubBy":"(a -> a -> Bool) -> [a] -> [a]",
			\"partition":"(a -> Bool) -> [a] -> ([a],[a])",
			\"sort":"Ord a => [a] -> [a]",
			\"sortBy":"(a -> a -> Ordering) -> [a] -> [a]",
			\"tails":"[a] -> [[a]]",
			\"transpose":"[[a]] -> [[a]]",
			\"unfoldr":"(a -> Maybe (b,a)) -> a -> [b]",
			\"union":"Eq a => [a] -> [a] -> [a]",
			\"unionBy":"(a -> a -> Bool) -> [a] -> [a] -> [a]",
			\"unzip4":"[(a,b,c,d)] -> ([a],[b],[c],[d])",
			\"unzip5":"[(a,b,c,d,e)] -> ([a],[b],[c],[d],[e])",
			\"unzip6":"[(a,b,c,d,e,f)] -> ([a],[b],[c],[d],[e],[f])",
			\"unzip7":"[(a,b,c,d,e,f,g)] -> ([a],[b],[c],[d],[e],[f],[g])",
			\"zip4":"[a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]",
			\"zip5":"[a] -> [b] -> [c] -> [d] -> [e] -> [(a,b,c,d,e)]",
			\"zip6":"[a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a,b,c,d,e,f)]",
			\"zip7":"[a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a,b,c,d,e,f,g)]",
			\"zipWith4":"(a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]",
			\"zipWith5":"(a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]",
			\"zipWith6":"(a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]",
			\"zipWith7":"(a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]",
		\},
		\'Locale':{
			\"defaultTimeLocale":"TimeLocale",
		\},
		\'Maybe':{
			\"catMaybes":"[Maybe a] -> [a]",
			\"fromJust":"Maybe a -> a",
			\"fromMaybe":"a -> Maybe a -> a",
			\"isJust":"Maybe a -> Bool",
			\"isNothing":"Maybe a -> Bool",
			\"listToMaybe":"[a] -> Maybe a",
			\"mapMaybe":"(a -> Maybe b) -> [a] -> [b]",
			\"maybeToList":"Maybe a -> [a]",
		\},
		\'Monad':{
			\"ap":"Monad a => a (b -> c) -> a b -> a c",
			\"filterM":"Monad a => (b -> a Bool) -> [b] -> a [b]",
			\"foldM":"Monad a => (b -> c -> a b) -> b -> [c] -> a b",
			\"guard":"MonadPlus a => Bool -> a ()",
			\"join":"Monad a => a (a b) -> a b",
			\"liftM":"Monad a => (b -> c) -> a b -> a c",
			\"liftM2":"Monad a => (b -> c -> d) -> a b -> a c -> a d",
			\"liftM3":"Monad a => (b -> c -> d -> e) -> a b -> a c -> a d -> a e",
			\"liftM4":"Monad a => (b -> c -> d -> e -> f) -> a b -> a c -> a d -> a e -> a f",
			\"liftM5":"Monad a => (b -> c -> d -> e -> f -> g) -> a b -> a c -> a d -> a e -> a f -> a g",
			\"mapAndUnzipM":"Monad a => (b -> a (c,d)) -> [b] -> a ([c],[d])",
			\"msum":"MonadPlus a => [a b] -> a b",
			\"unless":"Monad a => Bool -> a () -> a ()",
			\"when":"Monad a => Bool -> a () -> a ()",
			\"zipWithM":"Monad a => (b -> c -> a d) -> [b] -> [c] -> a [d]",
			\"zipWithM_":"Monad a => (b -> c -> a d) -> [b] -> [c] -> a ()",
		\},
		\'Network':{
			\"accept":"Socket -> IO (Handle, HostName, PortNumber)",
			\"connectTo":"HostName -> PortID -> IO Handle",
			\"listenOn":"PortID -> IO Socket",
			\"recvFrom":"HostName -> PortID -> IO String",
			\"sClose":"Socket -> IO ()",
			\"sendTo":"HostName -> PortID -> String -> IO ()",
			\"socketPort":"Socket -> IO PortID",
			\"withSocketsDo":"IO a -> IO a",
		\},
		\'Network.BSD':{
			\"getHostByAddr":"Family -> HostAddress -> IO HostEntry",
			\"getHostByName":"HostName -> IO HostEntry",
			\"getHostName":"IO HostName",
			\"getProtocolByName":"ProtocolName -> IO ProtocolEntry",
			\"getProtocolByNumber":"ProtocolNumber -> IO ProtocolEntry",
			\"getProtocolNumber":"ProtocolName -> IO ProtocolNumber",
			\"getServiceByName":"ServiceName -> ProtocolName -> IO ServiceEntry",
			\"getServiceByPort":"PortNumber -> ProtocolName -> IO ServiceEntry",
			\"getServicePortNumber":"ServiceName -> IO PortNumber",
			\"hostAddress":"HostEntry -> HostAddress",
			\"hostAddresses":"HostEntry -> [HostAddress]",
			\"hostAliases":"HostEntry -> [HostName]",
			\"hostFamily":"HostEntry -> Family",
			\"hostName":"HostEntry -> HostName",
			\"networkAddress":"NetworkEntry -> NetworkAddr",
			\"networkAliases":"NetworkEntry -> [NetworkName]",
			\"networkFamily":"NetworkEntry -> Family",
			\"networkName":"NetworkEntry -> NetworkName",
			\"protoAliases":"ProtocolEntry -> [ProtocolName]",
			\"protoName":"ProtocolEntry -> ProtocolName",
			\"protoNumber":"ProtocolEntry -> ProtocolNumber",
			\"serviceAliases":"ServiceEntry -> [ServiceName]",
			\"serviceName":"ServiceEntry -> ServiceName",
			\"servicePort":"ServiceEntry -> PortNumber",
			\"serviceProtocol":"ServiceEntry -> ProtocolName",
		\},
		\'Network.CGI':{
			\"connectToCGIScript":"String -> PortID -> IO ()",
			\"pwrapper":"PortID -> ([(String, String)] -> IO Html) -> IO ()",
			\"wrapper":"([(String, String)] -> IO Html) -> IO ()",
		\},
		\'Network.Socket':{
			\"aNY_PORT":"PortNumber",
			\"accept":"Socket -> IO (Socket, SockAddr)",
			\"bindSocket":"Socket -> SockAddr -> IO ()",
			\"connect":"Socket -> SockAddr -> IO ()",
			\"fdSocket":"Socket -> CInt",
			\"getPeerName":"Socket -> IO SockAddr",
			\"getSocketName":"Socket -> IO SockAddr",
			\"getSocketOption":"Socket -> SocketOption -> IO Int",
			\"iNADDR_ANY":"HostAddress",
			\"inet_addr":"String -> IO HostAddress",
			\"inet_ntoa":"HostAddress -> IO String",
			\"listen":"Socket -> Int -> IO ()",
			\"maxListenQueue":"Int",
			\"mkSocket":"CInt -> Family -> SocketType -> ProtocolNumber -> SocketStatus -> IO Socket",
			\"packFamily":"Family -> CInt",
			\"packSocketType":"SocketType -> CInt",
			\"recv":"Socket -> Int -> IO String",
			\"recvBufFrom":"Socket -> Ptr a -> Int -> IO (Int, SockAddr)",
			\"recvFrom":"Socket -> Int -> IO (String, Int, SockAddr)",
			\"recvLen":"Socket -> Int -> IO (String, Int)",
			\"sIsBound":"Socket -> IO Bool",
			\"sIsConnected":"Socket -> IO Bool",
			\"sIsListening":"Socket -> IO Bool",
			\"sIsReadable":"Socket -> IO Bool",
			\"sIsWritable":"Socket -> IO Bool",
			\"sOL_SOCKET":"Int",
			\"sOMAXCONN":"Int",
			\"send":"Socket -> String -> IO Int",
			\"sendBufTo":"Socket -> Ptr a -> Int -> SockAddr -> IO Int",
			\"sendTo":"Socket -> String -> SockAddr -> IO Int",
			\"setSocketOption":"Socket -> SocketOption -> Int -> IO ()",
			\"shutdown":"Socket -> ShutdownCmd -> IO ()",
			\"socket":"Family -> SocketType -> ProtocolNumber -> IO Socket",
			\"socketPort":"Socket -> IO PortNumber",
			\"socketToHandle":"Socket -> IOMode -> IO Handle",
			\"throwSocketErrorIfMinus1_":"Num a => String -> IO a -> IO ()",
			\"unpackFamily":"CInt -> Family",
		\},
		\'Network.URI':{
			\"authority":"URI -> String",
			\"escapeString":"String -> (Char -> Bool) -> String",
			\"escapeURIChar":"(Char -> Bool) -> Char -> String",
			\"escapeURIString":"(Char -> Bool) -> String -> String",
			\"fragment":"URI -> String",
			\"isAbsoluteURI":"String -> Bool",
			\"isAllowedInURI":"Char -> Bool",
			\"isIPv4address":"String -> Bool",
			\"isIPv6address":"String -> Bool",
			\"isRelativeReference":"String -> Bool",
			\"isReserved":"Char -> Bool",
			\"isURI":"String -> Bool",
			\"isURIReference":"String -> Bool",
			\"isUnescapedInURI":"Char -> Bool",
			\"isUnreserved":"Char -> Bool",
			\"nonStrictRelativeTo":"URI -> URI -> Maybe URI",
			\"normalizeCase":"String -> String",
			\"normalizeEscape":"String -> String",
			\"normalizePathSegments":"String -> String",
			\"nullURI":"URI",
			\"parseRelativeReference":"String -> Maybe URI",
			\"parseURI":"String -> Maybe URI",
			\"parseURIReference":"String -> Maybe URI",
			\"parseabsoluteURI":"String -> Maybe URI",
			\"path":"URI -> String",
			\"query":"URI -> String",
			\"relativeFrom":"URI -> URI -> URI",
			\"relativeTo":"URI -> URI -> Maybe URI",
			\"reserved":"Char -> Bool",
			\"scheme":"URI -> String",
			\"unEscapeString":"String -> String",
			\"unreserved":"Char -> Bool",
			\"uriAuthority":"URI -> Maybe URIAuth",
			\"uriFragment":"URI -> String",
			\"uriPath":"URI -> String",
			\"uriPort":"URIAuth -> String",
			\"uriQuery":"URI -> String",
			\"uriRegName":"URIAuth -> String",
			\"uriScheme":"URI -> String",
			\"uriToString":"(String -> String) -> URI -> ShowS",
			\"uriUserInfo":"URIAuth -> String",
		\},
		\'Numeric':{
			\"floatToDigits":"RealFloat a => Integer -> a -> ([Int], Int)",
			\"fromRat":"RealFloat a => Rational -> a",
			\"lexDigits":"ReadS String",
			\"readDec":"Num a => ReadS a",
			\"readFloat":"RealFrac a => ReadS a",
			\"readHex":"Num a => ReadS a",
			\"readInt":"Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a",
			\"readOct":"Num a => ReadS a",
			\"readSigned":"Real a => ReadS a -> ReadS a",
			\"showEFloat":"RealFloat a => Maybe Int -> a -> ShowS",
			\"showFFloat":"RealFloat a => Maybe Int -> a -> ShowS",
			\"showFloat":"RealFloat a => a -> ShowS",
			\"showGFloat":"RealFloat a => Maybe Int -> a -> ShowS",
			\"showHex":"Integral a => a -> ShowS",
			\"showInt":"Integral a => a -> ShowS",
			\"showIntAtBase":"Integral a => a -> (Int -> Char) -> a -> ShowS",
			\"showOct":"Integral a => a -> ShowS",
			\"showSigned":"Real a => (a -> ShowS) -> Int -> a -> ShowS",
		\},
		\'Prelude':{
			\"abs":"Num a => a -> a",
			\"acos":"Floating a => a -> a",
			\"acosh":"Floating a => a -> a",
			\"all":"(a -> Bool) -> [a] -> Bool",
			\"and":"[Bool] -> Bool",
			\"any":"(a -> Bool) -> [a] -> Bool",
			\"appendFile":"FilePath -> String -> IO ()",
			\"asTypeOf":"a -> a -> a",
			\"asin":"Floating a => a -> a",
			\"asinh":"Floating a => a -> a",
			\"atan":"Floating a => a -> a",
			\"atan2":"RealFloat a => a -> a -> a",
			\"atanh":"Floating a => a -> a",
			\"break":"(a -> Bool) -> [a] -> ([a], [a])",
			\"catch":"IO a -> (IOError -> IO a) -> IO a",
			\"ceiling":"(RealFrac a, Integral b) => a -> b",
			\"compare":"Ord a => a -> a -> Ordering",
			\"concat":"[[a]] -> [a]",
			\"concatMap":"(a -> [b]) -> [a] -> [b]",
			\"const":"a -> b -> a",
			\"cos":"Floating a => a -> a",
			\"cosh":"Floating a => a -> a",
			\"curry":"((a, b) -> c) -> a -> b -> c",
			\"cycle":"[a] -> [a]",
			\"decodeFloat":"RealFloat a => a -> (Integer,Int)",
			\"div":"Integral a => a -> a -> a",
			\"divMod":"Integral a => a -> a -> (a,a)",
			\"drop":"Int -> [a] -> [a]",
			\"dropWhile":"(a -> Bool) -> [a] -> [a]",
			\"either":"(a -> c) -> (b -> c) -> Either a b -> c",
			\"elem":"Eq a => a -> [a] -> Bool",
			\"encodeFloat":"RealFloat a => Integer -> Int -> a",
			\"enumFrom":"Enum a => a -> [a]",
			\"enumFromThen":"Enum a => a -> a -> [a]",
			\"enumFromThenTo":"Enum a => a -> a -> a -> [a]",
			\"enumFromTo":"Enum a => a -> a -> [a]",
			\"error":"String -> a",
			\"even":"Integral a => a -> Bool",
			\"exp":"Floating a => a -> a",
			\"exponent":"RealFloat a => a -> Int",
			\"fail":"Monad m => String -> m a",
			\"filter":"(a -> Bool) -> [a] -> [a]",
			\"flip":"(a -> b -> c) -> b -> a -> c",
			\"floatDigits":"RealFloat a => a -> Int",
			\"floatRadix":"RealFloat a => a -> Integer",
			\"floatRange":"RealFloat a => a -> (Int,Int)",
			\"floor":"(RealFrac a, Integral b) => a -> b",
			\"fmap":"Functor f => (a -> b) -> f a -> f b",
			\"foldl":"(a -> b -> a) -> a -> [b] -> a",
			\"foldl1":"(a -> a -> a) -> [a] -> a",
			\"foldr":"(a -> b -> b) -> b -> [a] -> b",
			\"foldr1":"(a -> a -> a) -> [a] -> a",
			\"fromEnum":"Enum a => a -> Int",
			\"fromInteger":"Num a => Integer -> a",
			\"fromIntegral":"(Integral a, Num b) => a -> b",
			\"fromRational":"Fractional a => Rational -> a",
			\"fst":"(a, b) -> a",
			\"gcd":"Integral a => a -> a -> a",
			\"getChar":"IO Char",
			\"getContents":"IO String",
			\"getLine":"IO String",
			\"head":"[a] -> a",
			\"id":"a -> a",
			\"init":"[a] -> [a]",
			\"interact":"(String -> String) -> IO ()",
			\"ioError":"IOError -> IO a",
			\"isDenormalized":"RealFloat a => a -> Bool",
			\"isIEEE":"RealFloat a => a -> Bool",
			\"isInfinite":"RealFloat a => a -> Bool",
			\"isNaN":"RealFloat a => a -> Bool",
			\"isNegativeZero":"RealFloat a => a -> Bool",
			\"iterate":"(a -> a) -> a -> [a]",
			\"last":"[a] -> a",
			\"lcm":"Integral a => a -> a -> a",
			\"length":"[a] -> Int",
			\"lex":"ReadS String",
			\"lines":"String -> [String]",
			\"log":"Floating a => a -> a",
			\"logBase":"Floating a => a -> a -> a",
			\"lookup":"Eq a => a -> [(a, b)] -> Maybe b",
			\"map":"(a -> b) -> [a] -> [b]",
			\"mapM":"Monad m => (a -> m b) -> [a] -> m [b]",
			\"mapM_":"Monad m => (a -> m b) -> [a] -> m ()",
			\"max":"Ord a => a -> a -> a",
			\"maxBound":"Bounded a => a",
			\"maximum":"Ord a => [a] -> a",
			\"maybe":"b -> (a -> b) -> Maybe a -> b",
			\"min":"Ord a => a -> a -> a",
			\"minBound":"Bounded a => a",
			\"minimum":"Ord a => [a] -> a",
			\"mod":"Integral a => a -> a -> a",
			\"negate":"Num a => a -> a",
			\"not":"Bool -> Bool",
			\"notElem":"Eq a => a -> [a] -> Bool",
			\"null":"[a] -> Bool",
			\"odd":"Integral a => a -> Bool",
			\"or":"[Bool] -> Bool",
			\"otherwise":"Bool",
			\"pi":"Floating a => a",
			\"pred":"Enum a => a -> a",
			\"print":"Show a => a -> IO ()",
			\"product":"Num a => [a] -> a",
			\"properFraction":"(RealFrac a, Integral b) => a -> (b,a)",
			\"putChar":"Char -> IO ()",
			\"putStr":"String -> IO ()",
			\"putStrLn":"String -> IO ()",
			\"quot":"Integral a => a -> a -> a",
			\"quotRem":"Integral a => a -> a -> (a,a)",
			\"read":"Read a => String -> a",
			\"readFile":"FilePath -> IO String",
			\"readIO":"Read a => String -> IO a",
			\"readList":"Read a => ReadS [a]",
			\"readLn":"Read a => IO a",
			\"readParen":"Bool -> ReadS a -> ReadS a",
			\"reads":"Read a => ReadS a",
			\"readsPrec":"Read a => Int -> ReadS a",
			\"realToFrac":"(Real a, Fractional b) => a -> b",
			\"recip":"Fractional a => a -> a",
			\"rem":"Integral a => a -> a -> a",
			\"repeat":"a -> [a]",
			\"replicate":"Int -> a -> [a]",
			\"return":"Monad m => a -> m a",
			\"reverse":"[a] -> [a]",
			\"round":"(RealFrac a, Integral b) => a -> b",
			\"scaleFloat":"RealFloat a => Int -> a -> a",
			\"scanl":"(a -> b -> a) -> a -> [b] -> [a]",
			\"scanl1":"(a -> a -> a) -> [a] -> [a]",
			\"scanr":"(a -> b -> b) -> b -> [a] -> [b]",
			\"scanr1":"(a -> a -> a) -> [a] -> [a]",
			\"seq":"a -> b -> b",
			\"sequence":"Monad m => [m a] -> m [a]",
			\"sequence_":"Monad m => [m a] -> m ()",
			\"show":"Show a => a -> String",
			\"showChar":"Char -> ShowS",
			\"showList":"Show a => [a] -> ShowS",
			\"showParen":"Bool -> ShowS -> ShowS",
			\"showString":"String -> ShowS",
			\"shows":"Show a => a -> ShowS",
			\"showsPrec":"Show a => Int -> a -> ShowS",
			\"significand":"RealFloat a => a -> a",
			\"signum":"Num a => a -> a",
			\"sin":"Floating a => a -> a",
			\"sinh":"Floating a => a -> a",
			\"snd":"(a, b) -> b",
			\"span":"(a -> Bool) -> [a] -> ([a], [a])",
			\"splitAt":"Int -> [a] -> ([a], [a])",
			\"sqrt":"Floating a => a -> a",
			\"subtract":"Num a => a -> a -> a",
			\"succ":"Enum a => a -> a",
			\"sum":"Num a => [a] -> a",
			\"tail":"[a] -> [a]",
			\"take":"Int -> [a] -> [a]",
			\"takeWhile":"(a -> Bool) -> [a] -> [a]",
			\"tan":"Floating a => a -> a",
			\"tanh":"Floating a => a -> a",
			\"toEnum":"Enum a => Int -> a",
			\"toInteger":"Integral a => a -> Integer",
			\"toRational":"Real a => a -> Rational",
			\"truncate":"(RealFrac a, Integral b) => a -> b",
			\"uncurry":"(a -> b -> c) -> (a, b) -> c",
			\"undefined":"a",
			\"unlines":"[String] -> String",
			\"until":"(a -> Bool) -> (a -> a) -> a -> a",
			\"unwords":"[String] -> String",
			\"unzip":"[(a, b)] -> ([a], [b])",
			\"unzip3":"[(a, b, c)] -> ([a], [b], [c])",
			\"userError":"String -> IOError",
			\"words":"String -> [String]",
			\"writeFile":"FilePath -> String -> IO ()",
			\"zip":"[a] -> [b] -> [(a, b)]",
			\"zip3":"[a] -> [b] -> [c] -> [(a, b, c)]",
			\"zipWith":"(a -> b -> c) -> [a] -> [b] -> [c]",
			\"zipWith3":"(a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]",
		\},
		\'Random':{
			\"getStdGen":"IO StdGen",
			\"getStdRandom":"(StdGen -> (a, StdGen)) -> IO a",
			\"mkStdGen":"Int -> StdGen",
			\"newStdGen":"IO StdGen",
			\"next":"RandomGen a => a -> (Int,a)",
			\"random":"(Random a, RandomGen b) => b -> (a,b)",
			\"randomIO":"Random a => IO a",
			\"randomR":"(Random a, RandomGen b) => (a,a) -> b -> (a,b)",
			\"randomRIO":"Random a => (a,a) -> IO a",
			\"randomRs":"(Random a, RandomGen b) => (a,a) -> b -> [a]",
			\"randoms":"(Random a, RandomGen b) => b -> [a]",
			\"setStdGen":"StdGen -> IO ()",
			\"split":"RandomGen a => a -> (a,a)",
		\},
		\'Ratio':{
			\"approxRational":"RealFrac a => a -> a -> Rational",
			\"denominator":"Integral a => Ratio a -> a",
			\"numerator":"Integral a => Ratio a -> a",
		\},
		\'System':{
			\"exitFailure":"IO a",
			\"exitWith":"ExitCode -> IO a",
			\"getArgs":"IO [String]",
			\"getEnv":"String -> IO String",
			\"getProgName":"IO String",
			\"system":"String -> IO ExitCode",
		\},
		\'System.Cmd':{
			\"rawSystem":"String -> [String] -> IO ExitCode",
		\},
		\'System.Console.Readline':{
			\"addDefun":"String -> Callback -> Maybe Char -> IO ()",
			\"addHistory":"String -> IO ()",
			\"addUndo":"UndoCode -> Int -> Int -> String -> IO ()",
			\"beginUndoGroup":"IO ()",
			\"bindKey":"Char -> Callback -> IO ()",
			\"bindKeyInMap":"Char -> Callback -> Keymap -> IO ()",
			\"callbackHandlerInstall":"String -> (String -> IO ()) -> IO (IO ())",
			\"callbackReadChar":"IO ()",
			\"clearMessage":"IO ()",
			\"clearSignals":"IO ()",
			\"complete":"Int -> Char -> IO Int",
			\"completeInternal":"Char -> IO ()",
			\"completionMatches":"String -> (String -> IO [String]) -> IO (Maybe (String, [String]))",
			\"copyKeymap":"Keymap -> IO Keymap",
			\"copyText":"Int -> Int -> IO String",
			\"deleteText":"Int -> Int -> IO ()",
			\"ding":"IO Bool",
			\"doUndo":"IO Bool",
			\"endUndoGroup":"IO ()",
			\"filenameCompletionFunction":"String -> IO [String]",
			\"forcedUpdateDisplay":"IO ()",
			\"freeKeymap":"Keymap -> IO ()",
			\"freeUndoList":"IO ()",
			\"functionDumper":"Bool -> IO ()",
			\"functionOfKeyseq":"String -> Maybe Keymap -> IO Entry",
			\"genericBind":"String -> Entry -> Keymap -> IO ()",
			\"getBasicQuoteCharacters":"IO String",
			\"getBasicWordBreakCharacters":"IO String",
			\"getBindingKeymap":"IO Keymap",
			\"getCompleterQuoteCharacters":"IO String",
			\"getCompleterWordBreakCharacters":"IO String",
			\"getCompletionAppendCharacter":"IO (Maybe Char)",
			\"getCompletionQueryItems":"IO Int",
			\"getEnd":"IO Int",
			\"getExecutingKeymap":"IO Keymap",
			\"getFilenameCompletionDesired":"IO Bool",
			\"getFilenameQuoteCharacters":"IO String",
			\"getFilenameQuotingDesired":"IO Bool",
			\"getIgnoreCompletionDuplicates":"IO Bool",
			\"getInStream":"IO Handle",
			\"getInhibitCompletion":"IO Bool",
			\"getKeymap":"IO Keymap",
			\"getKeymapByName":"String -> IO Keymap",
			\"getKeymapName":"Keymap -> IO (Maybe String)",
			\"getLibraryVersion":"IO String",
			\"getLineBuffer":"IO String",
			\"getMark":"IO Int",
			\"getOutStream":"IO Handle",
			\"getPoint":"IO Int",
			\"getPrompt":"IO String",
			\"getSpecialPrefixes":"IO String",
			\"getTerminalName":"IO String",
			\"initialize":"IO ()",
			\"insertCompletions":"Int -> Char -> IO Int",
			\"insertText":"String -> IO ()",
			\"killText":"Int -> Int -> IO ()",
			\"listFunmapNames":"IO ()",
			\"message":"String -> IO ()",
			\"modifying":"Int -> Int -> IO ()",
			\"namedFunction":"String -> IO (Maybe Callback)",
			\"newBareKeymap":"IO Keymap",
			\"newKeymap":"IO Keymap",
			\"onNewLine":"IO ()",
			\"parseAndBind":"String -> IO ()",
			\"possibleCompletions":"Int -> Char -> IO Int",
			\"quoteFilename":"String -> Bool -> Ptr CChar -> IO String",
			\"readInitFile":"String -> IO ()",
			\"readKey":"IO Char",
			\"readline":"String -> IO (Maybe String)",
			\"redisplay":"IO ()",
			\"resetLineState":"IO ()",
			\"resetTerminal":"Maybe String -> IO ()",
			\"setAttemptedCompletionFunction":"Maybe (String -> Int -> Int -> IO (Maybe (String, [String]))) -> IO ()",
			\"setBasicQuoteCharacters":"String -> IO ()",
			\"setBasicWordBreakCharacters":"String -> IO ()",
			\"setCharIsQuotedP":"Maybe (String -> Int -> IO Bool) -> IO ()",
			\"setCompleterQuoteCharacters":"String -> IO ()",
			\"setCompleterWordBreakCharacters":"String -> IO ()",
			\"setCompletionAppendCharacter":"Maybe Char -> IO ()",
			\"setCompletionEntryFunction":"Maybe (String -> IO [String]) -> IO ()",
			\"setCompletionQueryItems":"Int -> IO ()",
			\"setDirectoryCompletionHook":"Maybe (String -> IO String) -> IO ()",
			\"setDone":"Bool -> IO ()",
			\"setEnd":"Int -> IO ()",
			\"setEventHook":"Maybe (IO ()) -> IO ()",
			\"setFilenameCompletionDesired":"Bool -> IO ()",
			\"setFilenameDequotingFunction":"Maybe (String -> Maybe Char -> IO String) -> IO ()",
			\"setFilenameQuoteCharacters":"String -> IO ()",
			\"setFilenameQuotingDesired":"Bool -> IO ()",
			\"setFilenameQuotingFunction":"Maybe (String -> Bool -> Ptr CChar -> IO String) -> IO ()",
			\"setIgnoreCompletionDuplicates":"Bool -> IO ()",
			\"setIgnoreSomeCompletionsFunction":"Maybe ([String] -> IO [String]) -> IO ()",
			\"setInhibitCompletion":"Bool -> IO ()",
			\"setKeymap":"Keymap -> IO ()",
			\"setMark":"Int -> IO ()",
			\"setPendingInput":"Char -> IO ()",
			\"setPoint":"Int -> IO ()",
			\"setReadlineName":"String -> IO ()",
			\"setRedisplayFunction":"Maybe (IO ()) -> IO ()",
			\"setSignals":"IO ()",
			\"setSpecialPrefixes":"String -> IO ()",
			\"setStartupHook":"Maybe (IO ()) -> IO ()",
			\"stuffChar":"Char -> IO Bool",
			\"unbindCommandInMap":"String -> Keymap -> IO ()",
			\"unbindKey":"Char -> IO ()",
			\"unbindKeyInMap":"Char -> Keymap -> IO ()",
			\"usernameCompletionFunction":"String -> IO [String]",
		\},
		\'System.Console.SimpleLineEditor':{
			\"delChars":"String -> IO ()",
			\"getLineEdited":"String -> IO (Maybe String)",
			\"initialise":"IO ()",
			\"restore":"IO ()",
		\},
		\'System.Directory':{
			\"canonicalizePath":"FilePath -> IO FilePath",
			\"copyFile":"FilePath -> FilePath -> IO ()",
			\"createDirectoryIfMissing":"Bool -> FilePath -> IO ()",
			\"findExecutable":"String -> IO (Maybe FilePath)",
			\"getAppUserDataDirectory":"String -> IO FilePath",
			\"getHomeDirectory":"IO FilePath",
			\"getTemporaryDirectory":"IO FilePath",
			\"getUserDocumentsDirectory":"IO FilePath",
			\"removeDirectoryRecursive":"FilePath -> IO ()",
		\},
		\'System.Environment':{
			\"getEnvironment":"IO [(String, String)]",
			\"withArgs":"[String] -> IO a -> IO a",
			\"withProgName":"String -> IO a -> IO a",
		\},
		\'System.Exit':{
		\},
		\'System.IO':{
			\"fixIO":"(a -> IO a) -> IO a",
			\"hGetBuf":"Handle -> Ptr a -> Int -> IO Int",
			\"hGetBufNonBlocking":"Handle -> Ptr a -> Int -> IO Int",
			\"hGetEcho":"Handle -> IO Bool",
			\"hIsTerminalDevice":"Handle -> IO Bool",
			\"hPutBuf":"Handle -> Ptr a -> Int -> IO ()",
			\"hPutBufNonBlocking":"Handle -> Ptr a -> Int -> IO Int",
			\"hSetBinaryMode":"Handle -> Bool -> IO ()",
			\"hSetEcho":"Handle -> Bool -> IO ()",
			\"hSetFileSize":"Handle -> Integer -> IO ()",
			\"hShow":"Handle -> IO String",
			\"hTell":"Handle -> IO Integer",
			\"openBinaryFile":"FilePath -> IOMode -> IO Handle",
			\"openBinaryTempFile":"FilePath -> String -> IO (FilePath, Handle)",
			\"openTempFile":"FilePath -> String -> IO (FilePath, Handle)",
		\},
		\'System.IO.Error':{
			\"alreadyExistsErrorType":"IOErrorType",
			\"alreadyInUseErrorType":"IOErrorType",
			\"annotateIOError":"IOError -> String -> Maybe Handle -> Maybe FilePath -> IOError",
			\"doesNotExistErrorType":"IOErrorType",
			\"eofErrorType":"IOErrorType",
			\"fullErrorType":"IOErrorType",
			\"illegalOperationErrorType":"IOErrorType",
			\"ioeGetErrorType":"IOError -> IOErrorType",
			\"ioeSetErrorString":"IOError -> String -> IOError",
			\"ioeSetErrorType":"IOError -> IOErrorType -> IOError",
			\"ioeSetFileName":"IOError -> FilePath -> IOError",
			\"ioeSetHandle":"IOError -> Handle -> IOError",
			\"isAlreadyExistsErrorType":"IOErrorType -> Bool",
			\"isAlreadyInUseErrorType":"IOErrorType -> Bool",
			\"isDoesNotExistErrorType":"IOErrorType -> Bool",
			\"isEOFErrorType":"IOErrorType -> Bool",
			\"isFullErrorType":"IOErrorType -> Bool",
			\"isIllegalOperationErrorType":"IOErrorType -> Bool",
			\"isPermissionErrorType":"IOErrorType -> Bool",
			\"isUserErrorType":"IOErrorType -> Bool",
			\"mkIOError":"IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError",
			\"modifyIOError":"(IOError -> IOError) -> IO a -> IO a",
			\"permissionErrorType":"IOErrorType",
			\"userErrorType":"IOErrorType",
		\},
		\'System.IO.Unsafe':{
			\"unsafeInterleaveIO":"IO a -> IO a",
		\},
		\'System.Info':{
			\"arch":"String",
			\"compilerName":"String",
			\"compilerVersion":"Version",
			\"os":"String",
		\},
		\'System.Locale':{
			\"amPm":"TimeLocale -> String,String",
			\"dateFmt":"TimeLocale -> String",
			\"dateTimeFmt":"TimeLocale -> String",
			\"intervals":"TimeLocale -> [(String,String)]",
			\"iso8601DateFormat":"Maybe String -> String",
			\"months":"TimeLocale -> [(String,String)]",
			\"rfc822DateFormat":"String",
			\"time12Fmt":"TimeLocale -> String",
			\"timeFmt":"TimeLocale -> String",
			\"wDays":"TimeLocale -> [(String,String)]",
		\},
		\'System.Mem':{
			\"performGC":"IO ()",
		\},
		\'System.Mem.StableName':{
			\"hashStableName":"StableName a -> Int",
			\"makeStableName":"a -> IO (StableName a)",
		\},
		\'System.Mem.Weak':{
			\"addFinalizer":"key -> IO () -> IO ()",
			\"deRefWeak":"Weak v -> IO (Maybe v)",
			\"finalize":"Weak v -> IO ()",
			\"mkWeak":"k -> v -> Maybe (IO ()) -> IO (Weak v)",
			\"mkWeakPair":"k -> v -> Maybe (IO ()) -> IO (Weak (k, v))",
			\"mkWeakPtr":"k -> Maybe (IO ()) -> IO (Weak k)",
		\},
		\'System.Posix.Types':{
		\},
		\'System.Process':{
			\"getProcessExitCode":"ProcessHandle -> IO (Maybe ExitCode)",
			\"runCommand":"String -> IO ProcessHandle",
			\"runInteractiveCommand":"String -> IO (Handle, Handle, Handle, ProcessHandle)",
			\"runInteractiveProcess":"FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)",
			\"runProcess":"FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle",
			\"terminateProcess":"ProcessHandle -> IO ()",
			\"waitForProcess":"ProcessHandle -> IO ExitCode",
		\},
		\'System.Random':{
			\"genRange":"RandomGen g => g -> (Int,Int)",
			\"next":"RandomGen g => g -> (Int,g)",
			\"random":"(Random a, RandomGen g) => g -> (a,g)",
			\"randomR":"(Random a, RandomGen g) => (a,a) -> g -> (a,g)",
			\"randomRs":"(Random a, RandomGen g) => (a,a) -> g -> [a]",
			\"randoms":"(Random a, RandomGen g) => g -> [a]",
			\"split":"RandomGen g => g -> (g,g)",
		\},
		\'System.Time':{
			\"ctDay":"CalendarTime -> Int",
			\"ctHour":"CalendarTime -> Int",
			\"ctIsDST":"CalendarTime -> Bool",
			\"ctMin":"CalendarTime -> Int",
			\"ctMonth":"CalendarTime -> Month",
			\"ctPicosec":"CalendarTime -> Integer",
			\"ctSec":"CalendarTime -> Int",
			\"ctTZ":"CalendarTime -> Int",
			\"ctTZName":"CalendarTime -> String",
			\"ctWDay":"CalendarTime -> Day",
			\"ctYDay":"CalendarTime -> Int",
			\"ctYear":"CalendarTime -> Int",
			\"formatTimeDiff":"TimeLocale -> String -> TimeDiff -> String",
			\"noTimeDiff":"TimeDiff",
			\"normalizeTimeDiff":"TimeDiff -> TimeDiff",
			\"tdDay":"TimeDiff -> Int",
			\"tdHour":"TimeDiff -> Int",
			\"tdMin":"TimeDiff -> Int",
			\"tdMonth":"TimeDiff -> Int",
			\"tdPicosec":"TimeDiff -> Integer",
			\"tdSec":"TimeDiff -> Int",
			\"tdYear":"TimeDiff -> Int",
			\"timeDiffToString":"TimeDiff -> String",
		\},
		\'System.Win32.DLL':{
			\"c_DisableThreadLibraryCalls":"HMODULE -> IO Bool",
			\"c_FreeLibrary":"HMODULE -> IO Bool",
			\"c_GetModuleFileName":"HMODULE -> LPTSTR -> Int -> IO Bool",
			\"c_GetModuleHandle":"LPCTSTR -> IO HMODULE",
			\"c_GetProcAddress":"HMODULE -> LPCSTR -> IO Addr",
			\"c_LoadLibrary":"LPCTSTR -> IO HINSTANCE",
			\"c_LoadLibraryEx":"LPCTSTR -> HANDLE -> LoadLibraryFlags -> IO HINSTANCE",
			\"disableThreadLibraryCalls":"HMODULE -> IO ()",
			\"freeLibrary":"HMODULE -> IO ()",
			\"getModuleFileName":"HMODULE -> IO String",
			\"getModuleHandle":"Maybe String -> IO HMODULE",
			\"getProcAddress":"HMODULE -> String -> IO Addr",
			\"lOAD_LIBRARY_AS_DATAFILE":"LoadLibraryFlags",
			\"lOAD_WITH_ALTERED_SEARCH_PATH":"LoadLibraryFlags",
			\"loadLibrary":"String -> IO HINSTANCE",
			\"loadLibraryEx":"String -> HANDLE -> LoadLibraryFlags -> IO HINSTANCE",
		\},
		\'System.Win32.File':{
			\"aCCESS_SYSTEM_SECURITY":"AccessMode",
			\"areFileApisANSI":"IO Bool",
			\"cREATE_ALWAYS":"CreateMode",
			\"cREATE_NEW":"CreateMode",
			\"c_CloseHandle":"HANDLE -> IO Bool",
			\"c_CopyFile":"LPCTSTR -> LPCTSTR -> Bool -> IO Bool",
			\"c_CreateDirectory":"LPCTSTR -> LPSECURITY_ATTRIBUTES -> IO Bool",
			\"c_CreateDirectoryEx":"LPCTSTR -> LPCTSTR -> LPSECURITY_ATTRIBUTES -> IO Bool",
			\"c_CreateFile":"LPCTSTR -> AccessMode -> ShareMode -> LPSECURITY_ATTRIBUTES -> CreateMode -> FileAttributeOrFlag -> HANDLE -> IO HANDLE",
			\"c_DefineDosDevice":"DefineDosDeviceFlags -> LPCTSTR -> LPCTSTR -> IO Bool",
			\"c_DeleteFile":"LPCTSTR -> IO Bool",
			\"c_FindCloseChangeNotification":"HANDLE -> IO Bool",
			\"c_FindFirstChangeNotification":"LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE",
			\"c_FindNextChangeNotification":"HANDLE -> IO Bool",
			\"c_FlushFileBuffers":"HANDLE -> IO Bool",
			\"c_GetBinaryType":"LPCTSTR -> Ptr DWORD -> IO Bool",
			\"c_GetDiskFreeSpace":"LPCTSTR -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> IO Bool",
			\"c_GetFileAttributes":"LPCTSTR -> IO FileAttributeOrFlag",
			\"c_GetLogicalDrives":"IO DWORD",
			\"c_MoveFile":"LPCTSTR -> LPCTSTR -> IO Bool",
			\"c_MoveFileEx":"LPCTSTR -> LPCTSTR -> MoveFileFlag -> IO Bool",
			\"c_ReadFile":"HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool",
			\"c_RemoveDirectory":"LPCTSTR -> IO Bool",
			\"c_SetCurrentDirectory":"LPCTSTR -> IO Bool",
			\"c_SetEndOfFile":"HANDLE -> IO Bool",
			\"c_SetFileAttributes":"LPCTSTR -> FileAttributeOrFlag -> IO Bool",
			\"c_SetVolumeLabel":"LPCTSTR -> LPCTSTR -> IO Bool",
			\"c_WriteFile":"HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool",
			\"closeHandle":"HANDLE -> IO ()",
			\"copyFile":"String -> String -> Bool -> IO ()",
			\"createDirectory":"String -> Maybe LPSECURITY_ATTRIBUTES -> IO ()",
			\"createDirectoryEx":"String -> String -> Maybe LPSECURITY_ATTRIBUTES -> IO ()",
			\"createFile":"String -> AccessMode -> ShareMode -> Maybe LPSECURITY_ATTRIBUTES -> CreateMode -> FileAttributeOrFlag -> Maybe HANDLE -> IO HANDLE",
			\"dDD_EXACT_MATCH_ON_REMOVE":"DefineDosDeviceFlags",
			\"dDD_RAW_TARGET_PATH":"DefineDosDeviceFlags",
			\"dDD_REMOVE_DEFINITION":"DefineDosDeviceFlags",
			\"dELETE":"AccessMode",
			\"dRIVE_CDROM":"DriveType",
			\"dRIVE_FIXED":"DriveType",
			\"dRIVE_NO_ROOT_DIR":"DriveType",
			\"dRIVE_RAMDISK":"DriveType",
			\"dRIVE_REMOTE":"DriveType",
			\"dRIVE_REMOVABLE":"DriveType",
			\"dRIVE_UNKNOWN":"DriveType",
			\"defineDosDevice":"DefineDosDeviceFlags -> String -> String -> IO ()",
			\"deleteFile":"String -> IO ()",
			\"fILE_ATTRIBUTE_ARCHIVE":"FileAttributeOrFlag",
			\"fILE_ATTRIBUTE_COMPRESSED":"FileAttributeOrFlag",
			\"fILE_ATTRIBUTE_DIRECTORY":"FileAttributeOrFlag",
			\"fILE_ATTRIBUTE_HIDDEN":"FileAttributeOrFlag",
			\"fILE_ATTRIBUTE_NORMAL":"FileAttributeOrFlag",
			\"fILE_ATTRIBUTE_READONLY":"FileAttributeOrFlag",
			\"fILE_ATTRIBUTE_SYSTEM":"FileAttributeOrFlag",
			\"fILE_ATTRIBUTE_TEMPORARY":"FileAttributeOrFlag",
			\"fILE_BEGIN":"FilePtrDirection",
			\"fILE_CURRENT":"FilePtrDirection",
			\"fILE_END":"FilePtrDirection",
			\"fILE_FLAG_BACKUP_SEMANTICS":"FileAttributeOrFlag",
			\"fILE_FLAG_DELETE_ON_CLOSE":"FileAttributeOrFlag",
			\"fILE_FLAG_NO_BUFFERING":"FileAttributeOrFlag",
			\"fILE_FLAG_OVERLAPPED":"FileAttributeOrFlag",
			\"fILE_FLAG_POSIX_SEMANTICS":"FileAttributeOrFlag",
			\"fILE_FLAG_RANDOM_ACCESS":"FileAttributeOrFlag",
			\"fILE_FLAG_SEQUENTIAL_SCAN":"FileAttributeOrFlag",
			\"fILE_FLAG_WRITE_THROUGH":"FileAttributeOrFlag",
			\"fILE_NOTIFY_CHANGE_ATTRIBUTES":"FileNotificationFlag",
			\"fILE_NOTIFY_CHANGE_DIR_NAME":"FileNotificationFlag",
			\"fILE_NOTIFY_CHANGE_FILE_NAME":"FileNotificationFlag",
			\"fILE_NOTIFY_CHANGE_LAST_WRITE":"FileNotificationFlag",
			\"fILE_NOTIFY_CHANGE_SECURITY":"FileNotificationFlag",
			\"fILE_NOTIFY_CHANGE_SIZE":"FileNotificationFlag",
			\"fILE_SHARE_NONE":"ShareMode",
			\"fILE_SHARE_READ":"ShareMode",
			\"fILE_SHARE_WRITE":"ShareMode",
			\"fILE_TYPE_CHAR":"FileType",
			\"fILE_TYPE_DISK":"FileType",
			\"fILE_TYPE_PIPE":"FileType",
			\"fILE_TYPE_REMOTE":"FileType",
			\"fILE_TYPE_UNKNOWN":"FileType",
			\"findCloseChangeNotification":"HANDLE -> IO ()",
			\"findFirstChangeNotification":"String -> Bool -> FileNotificationFlag -> IO HANDLE",
			\"findNextChangeNotification":"HANDLE -> IO ()",
			\"flushFileBuffers":"HANDLE -> IO ()",
			\"gENERIC_ALL":"AccessMode",
			\"gENERIC_EXECUTE":"AccessMode",
			\"gENERIC_NONE":"AccessMode",
			\"gENERIC_READ":"AccessMode",
			\"gENERIC_WRITE":"AccessMode",
			\"getBinaryType":"String -> IO BinaryType",
			\"getDiskFreeSpace":"Maybe String -> IO (DWORD, DWORD, DWORD, DWORD)",
			\"getFileAttributes":"String -> IO FileAttributeOrFlag",
			\"getFileType":"HANDLE -> IO FileType",
			\"getLogicalDrives":"IO DWORD",
			\"mAXIMUM_ALLOWED":"AccessMode",
			\"mOVEFILE_COPY_ALLOWED":"MoveFileFlag",
			\"mOVEFILE_DELAY_UNTIL_REBOOT":"MoveFileFlag",
			\"mOVEFILE_REPLACE_EXISTING":"MoveFileFlag",
			\"moveFile":"String -> String -> IO ()",
			\"moveFileEx":"String -> String -> MoveFileFlag -> IO ()",
			\"oPEN_ALWAYS":"CreateMode",
			\"oPEN_EXISTING":"CreateMode",
			\"rEAD_CONTROL":"AccessMode",
			\"removeDirectory":"String -> IO ()",
			\"sCS_32BIT_BINARY":"BinaryType",
			\"sCS_DOS_BINARY":"BinaryType",
			\"sCS_OS216_BINARY":"BinaryType",
			\"sCS_PIF_BINARY":"BinaryType",
			\"sCS_POSIX_BINARY":"BinaryType",
			\"sCS_WOW_BINARY":"BinaryType",
			\"sECURITY_ANONYMOUS":"FileAttributeOrFlag",
			\"sECURITY_CONTEXT_TRACKING":"FileAttributeOrFlag",
			\"sECURITY_DELEGATION":"FileAttributeOrFlag",
			\"sECURITY_EFFECTIVE_ONLY":"FileAttributeOrFlag",
			\"sECURITY_IDENTIFICATION":"FileAttributeOrFlag",
			\"sECURITY_IMPERSONATION":"FileAttributeOrFlag",
			\"sECURITY_SQOS_PRESENT":"FileAttributeOrFlag",
			\"sECURITY_VALID_SQOS_FLAGS":"FileAttributeOrFlag",
			\"sPECIFIC_RIGHTS_ALL":"AccessMode",
			\"sTANDARD_RIGHTS_ALL":"AccessMode",
			\"sTANDARD_RIGHTS_EXECUTE":"AccessMode",
			\"sTANDARD_RIGHTS_READ":"AccessMode",
			\"sTANDARD_RIGHTS_REQUIRED":"AccessMode",
			\"sTANDARD_RIGHTS_WRITE":"AccessMode",
			\"sYNCHRONIZE":"AccessMode",
			\"setCurrentDirectory":"String -> IO ()",
			\"setEndOfFile":"HANDLE -> IO ()",
			\"setFileApisToANSI":"IO ()",
			\"setFileApisToOEM":"IO ()",
			\"setFileAttributes":"String -> FileAttributeOrFlag -> IO ()",
			\"setHandleCount":"UINT -> IO UINT",
			\"setVolumeLabel":"String -> String -> IO ()",
			\"tRUNCATE_EXISTING":"CreateMode",
			\"wRITE_DAC":"AccessMode",
			\"wRITE_OWNER":"AccessMode",
			\"win32_ReadFile":"HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD",
			\"win32_WriteFile":"HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD",
		\},
		\'System.Win32.Info':{
			\"cOLOR_ACTIVEBORDER":"SystemColor",
			\"cOLOR_ACTIVECAPTION":"SystemColor",
			\"cOLOR_APPWORKSPACE":"SystemColor",
			\"cOLOR_BACKGROUND":"SystemColor",
			\"cOLOR_BTNFACE":"SystemColor",
			\"cOLOR_BTNHIGHLIGHT":"SystemColor",
			\"cOLOR_BTNSHADOW":"SystemColor",
			\"cOLOR_BTNTEXT":"SystemColor",
			\"cOLOR_CAPTIONTEXT":"SystemColor",
			\"cOLOR_GRAYTEXT":"SystemColor",
			\"cOLOR_HIGHLIGHT":"SystemColor",
			\"cOLOR_HIGHLIGHTTEXT":"SystemColor",
			\"cOLOR_INACTIVEBORDER":"SystemColor",
			\"cOLOR_INACTIVECAPTION":"SystemColor",
			\"cOLOR_INACTIVECAPTIONTEXT":"SystemColor",
			\"cOLOR_MENU":"SystemColor",
			\"cOLOR_MENUTEXT":"SystemColor",
			\"cOLOR_SCROLLBAR":"SystemColor",
			\"cOLOR_WINDOW":"SystemColor",
			\"cOLOR_WINDOWFRAME":"SystemColor",
			\"cOLOR_WINDOWTEXT":"SystemColor",
			\"sM_ARRANGE":"SMSetting",
			\"sM_CLEANBOOT":"SMSetting",
			\"sM_CMETRICS":"SMSetting",
			\"sM_CMOUSEBUTTONS":"SMSetting",
			\"sM_CXBORDER":"SMSetting",
			\"sM_CXCURSOR":"SMSetting",
			\"sM_CXDLGFRAME":"SMSetting",
			\"sM_CXDOUBLECLK":"SMSetting",
			\"sM_CXDRAG":"SMSetting",
			\"sM_CXEDGE":"SMSetting",
			\"sM_CXFRAME":"SMSetting",
			\"sM_CXFULLSCREEN":"SMSetting",
			\"sM_CXHSCROLL":"SMSetting",
			\"sM_CXICON":"SMSetting",
			\"sM_CXICONSPACING":"SMSetting",
			\"sM_CXMAXIMIZED":"SMSetting",
			\"sM_CXMENUCHECK":"SMSetting",
			\"sM_CXMENUSIZE":"SMSetting",
			\"sM_CXMIN":"SMSetting",
			\"sM_CXMINIMIZED":"SMSetting",
			\"sM_CXMINTRACK":"SMSetting",
			\"sM_CXSCREEN":"SMSetting",
			\"sM_CXSIZE":"SMSetting",
			\"sM_CXSIZEFRAME":"SMSetting",
			\"sM_CXSMICON":"SMSetting",
			\"sM_CXSMSIZE":"SMSetting",
			\"sM_CXVSCROLL":"SMSetting",
			\"sM_CYBORDER":"SMSetting",
			\"sM_CYCAPTION":"SMSetting",
			\"sM_CYCURSOR":"SMSetting",
			\"sM_CYDLGFRAME":"SMSetting",
			\"sM_CYDOUBLECLK":"SMSetting",
			\"sM_CYDRAG":"SMSetting",
			\"sM_CYEDGE":"SMSetting",
			\"sM_CYFRAME":"SMSetting",
			\"sM_CYFULLSCREEN":"SMSetting",
			\"sM_CYHSCROLL":"SMSetting",
			\"sM_CYICON":"SMSetting",
			\"sM_CYICONSPACING":"SMSetting",
			\"sM_CYKANJIWINDOW":"SMSetting",
			\"sM_CYMAXIMIZED":"SMSetting",
			\"sM_CYMENU":"SMSetting",
			\"sM_CYMENUCHECK":"SMSetting",
			\"sM_CYMENUSIZE":"SMSetting",
			\"sM_CYMIN":"SMSetting",
			\"sM_CYMINIMIZED":"SMSetting",
			\"sM_CYMINTRACK":"SMSetting",
			\"sM_CYSCREEN":"SMSetting",
			\"sM_CYSIZE":"SMSetting",
			\"sM_CYSIZEFRAME":"SMSetting",
			\"sM_CYSMCAPTION":"SMSetting",
			\"sM_CYSMICON":"SMSetting",
			\"sM_CYSMSIZE":"SMSetting",
			\"sM_CYVSCROLL":"SMSetting",
			\"sM_CYVTHUMB":"SMSetting",
			\"sM_DBCSENABLED":"SMSetting",
			\"sM_DEBUG":"SMSetting",
			\"sM_MENUDROPALIGNMENT":"SMSetting",
			\"sM_MIDEASTENABLED":"SMSetting",
			\"sM_MOUSEPRESENT":"SMSetting",
			\"sM_NETWORK":"SMSetting",
			\"sM_PENWINDOWS":"SMSetting",
			\"sM_SECURE":"SMSetting",
			\"sM_SHOWSOUNDS":"SMSetting",
			\"sM_SLOWMACHINE":"SMSetting",
			\"sM_SWAPBUTTON":"SMSetting",
		\},
		\'System.Win32.Mem':{
			\"c_GlobalAlloc":"GlobalAllocFlags -> DWORD -> IO HGLOBAL",
			\"c_GlobalFlags":"HGLOBAL -> IO GlobalAllocFlags",
			\"c_GlobalFree":"HGLOBAL -> IO HGLOBAL",
			\"c_GlobalHandle":"Addr -> IO HGLOBAL",
			\"c_GlobalLock":"HGLOBAL -> IO Addr",
			\"c_GlobalReAlloc":"HGLOBAL -> DWORD -> GlobalAllocFlags -> IO HGLOBAL",
			\"c_GlobalSize":"HGLOBAL -> IO DWORD",
			\"c_GlobalUnlock":"HGLOBAL -> IO Bool",
			\"c_HeapAlloc":"HANDLE -> HeapAllocFlags -> DWORD -> IO Addr",
			\"c_HeapCompact":"HANDLE -> HeapAllocFlags -> IO UINT",
			\"c_HeapCreate":"HeapAllocFlags -> DWORD -> DWORD -> IO HANDLE",
			\"c_HeapDestroy":"HANDLE -> IO Bool",
			\"c_HeapFree":"HANDLE -> HeapAllocFlags -> Addr -> IO Bool",
			\"c_HeapLock":"HANDLE -> IO Bool",
			\"c_HeapReAlloc":"HANDLE -> HeapAllocFlags -> Addr -> DWORD -> IO Addr",
			\"c_HeapSize":"HANDLE -> HeapAllocFlags -> Addr -> IO DWORD",
			\"c_HeapUnlock":"HANDLE -> IO Bool",
			\"c_VirtualAlloc":"Addr -> DWORD -> DWORD -> DWORD -> IO Addr",
			\"c_VirtualFree":"Addr -> DWORD -> FreeFlags -> IO Bool",
			\"c_VirtualLock":"Addr -> DWORD -> IO Bool",
			\"c_VirtualProtect":"Addr -> DWORD -> DWORD -> Ptr DWORD -> IO Bool",
			\"c_VirtualProtectEx":"HANDLE -> Addr -> DWORD -> DWORD -> Ptr DWORD -> IO Bool",
			\"c_VirtualUnlock":"Addr -> DWORD -> IO Bool",
			\"copyMemory":"Ptr a -> Ptr a -> DWORD -> IO ()",
			\"fillMemory":"Ptr a -> DWORD -> BYTE -> IO ()",
			\"gHND":"GlobalAllocFlags",
			\"gMEM_DDESHARE":"GlobalAllocFlags",
			\"gMEM_FIXED":"GlobalAllocFlags",
			\"gMEM_INVALID_HANDLE":"GlobalAllocFlags",
			\"gMEM_LOWER":"GlobalAllocFlags",
			\"gMEM_MOVEABLE":"GlobalAllocFlags",
			\"gMEM_NOCOMPACT":"GlobalAllocFlags",
			\"gMEM_NODISCARD":"GlobalAllocFlags",
			\"gMEM_NOTIFY":"GlobalAllocFlags",
			\"gMEM_NOT_BANKED":"GlobalAllocFlags",
			\"gMEM_SHARE":"GlobalAllocFlags",
			\"gMEM_ZEROINIT":"GlobalAllocFlags",
			\"gPTR":"GlobalAllocFlags",
			\"getProcessHeap":"IO HANDLE",
			\"getProcessHeaps":"DWORD -> Addr -> IO DWORD",
			\"globalAlloc":"GlobalAllocFlags -> DWORD -> IO HGLOBAL",
			\"globalFlags":"HGLOBAL -> IO GlobalAllocFlags",
			\"globalFree":"HGLOBAL -> IO HGLOBAL",
			\"globalHandle":"Addr -> IO HGLOBAL",
			\"globalLock":"HGLOBAL -> IO Addr",
			\"globalReAlloc":"HGLOBAL -> DWORD -> GlobalAllocFlags -> IO HGLOBAL",
			\"globalSize":"HGLOBAL -> IO DWORD",
			\"globalUnlock":"HGLOBAL -> IO ()",
			\"hEAP_GENERATE_EXCEPTIONS":"HeapAllocFlags",
			\"hEAP_NO_SERIALIZE":"HeapAllocFlags",
			\"hEAP_ZERO_MEMORY":"HeapAllocFlags",
			\"heapAlloc":"HANDLE -> HeapAllocFlags -> DWORD -> IO Addr",
			\"heapCompact":"HANDLE -> HeapAllocFlags -> IO UINT",
			\"heapCreate":"HeapAllocFlags -> DWORD -> DWORD -> IO HANDLE",
			\"heapDestroy":"HANDLE -> IO ()",
			\"heapFree":"HANDLE -> HeapAllocFlags -> Addr -> IO ()",
			\"heapLock":"HANDLE -> IO ()",
			\"heapReAlloc":"HANDLE -> HeapAllocFlags -> Addr -> DWORD -> IO Addr",
			\"heapSize":"HANDLE -> HeapAllocFlags -> Addr -> IO DWORD",
			\"heapUnlock":"HANDLE -> IO ()",
			\"heapValidate":"HANDLE -> HeapAllocFlags -> Addr -> IO Bool",
			\"mEM_COMMIT":"VirtualAllocFlags",
			\"mEM_DECOMMIT":"FreeFlags",
			\"mEM_RELEASE":"FreeFlags",
			\"mEM_RESERVE":"VirtualAllocFlags",
			\"memset":"Ptr a -> CInt -> CSize -> IO ()",
			\"moveMemory":"Ptr a -> Ptr a -> DWORD -> IO ()",
			\"pAGE_EXECUTE":"ProtectFlags",
			\"pAGE_EXECUTE_READ":"ProtectFlags",
			\"pAGE_EXECUTE_READWRITE":"ProtectFlags",
			\"pAGE_GUARD":"ProtectFlags",
			\"pAGE_NOACCESS":"ProtectFlags",
			\"pAGE_NOCACHE":"ProtectFlags",
			\"pAGE_READONLY":"ProtectFlags",
			\"pAGE_READWRITE":"ProtectFlags",
			\"virtualAlloc":"Addr -> DWORD -> VirtualAllocFlags -> ProtectFlags -> IO Addr",
			\"virtualFree":"Addr -> DWORD -> FreeFlags -> IO ()",
			\"virtualLock":"Addr -> DWORD -> IO ()",
			\"virtualProtect":"Addr -> DWORD -> ProtectFlags -> IO ProtectFlags",
			\"virtualProtectEx":"HANDLE -> Addr -> DWORD -> ProtectFlags -> IO ProtectFlags",
			\"virtualUnlock":"Addr -> DWORD -> IO ()",
			\"zeroMemory":"Ptr a -> DWORD -> IO ()",
		\},
		\'System.Win32.NLS':{
			\"cP_ACP":"CodePage",
			\"cP_MACCP":"CodePage",
			\"cP_OEMCP":"CodePage",
			\"c_LCMapString":"LCID -> LCMapFlags -> LPCTSTR -> Int -> LPCTSTR -> Int -> IO Int",
			\"c_SetLocaleInfo":"LCID -> LCTYPE -> LPCTSTR -> IO Bool",
			\"convertDefaultLocale":"LCID -> IO LCID",
			\"getACP":"IO CodePage",
			\"getOEMCP":"CodePage",
			\"getSystemDefaultLCID":"LCID",
			\"getSystemDefaultLangID":"LANGID",
			\"getThreadLocale":"IO LCID",
			\"getUserDefaultLCID":"LCID",
			\"getUserDefaultLangID":"LANGID",
			\"isValidCodePage":"CodePage -> IO Bool",
			\"isValidLocale":"LCID -> LocaleTestFlags -> IO Bool",
			\"lANGIDFROMLCID":"LCID -> LANGID",
			\"lANG_AFRIKAANS":"PrimaryLANGID",
			\"lANG_ALBANIAN":"PrimaryLANGID",
			\"lANG_ARABIC":"PrimaryLANGID",
			\"lANG_ARMENIAN":"PrimaryLANGID",
			\"lANG_ASSAMESE":"PrimaryLANGID",
			\"lANG_AZERI":"PrimaryLANGID",
			\"lANG_BASQUE":"PrimaryLANGID",
			\"lANG_BELARUSIAN":"PrimaryLANGID",
			\"lANG_BENGALI":"PrimaryLANGID",
			\"lANG_BULGARIAN":"PrimaryLANGID",
			\"lANG_CATALAN":"PrimaryLANGID",
			\"lANG_CHINESE":"PrimaryLANGID",
			\"lANG_CROATIAN":"PrimaryLANGID",
			\"lANG_CZECH":"PrimaryLANGID",
			\"lANG_DANISH":"PrimaryLANGID",
			\"lANG_DUTCH":"PrimaryLANGID",
			\"lANG_ENGLISH":"PrimaryLANGID",
			\"lANG_ESTONIAN":"PrimaryLANGID",
			\"lANG_FAEROESE":"PrimaryLANGID",
			\"lANG_FARSI":"PrimaryLANGID",
			\"lANG_FINNISH":"PrimaryLANGID",
			\"lANG_FRENCH":"PrimaryLANGID",
			\"lANG_GEORGIAN":"PrimaryLANGID",
			\"lANG_GERMAN":"PrimaryLANGID",
			\"lANG_GREEK":"PrimaryLANGID",
			\"lANG_GUJARATI":"PrimaryLANGID",
			\"lANG_HEBREW":"PrimaryLANGID",
			\"lANG_HINDI":"PrimaryLANGID",
			\"lANG_HUNGARIAN":"PrimaryLANGID",
			\"lANG_ICELANDIC":"PrimaryLANGID",
			\"lANG_INDONESIAN":"PrimaryLANGID",
			\"lANG_ITALIAN":"PrimaryLANGID",
			\"lANG_JAPANESE":"PrimaryLANGID",
			\"lANG_KANNADA":"PrimaryLANGID",
			\"lANG_KASHMIRI":"PrimaryLANGID",
			\"lANG_KAZAK":"PrimaryLANGID",
			\"lANG_KONKANI":"PrimaryLANGID",
			\"lANG_KOREAN":"PrimaryLANGID",
			\"lANG_LATVIAN":"PrimaryLANGID",
			\"lANG_LITHUANIAN":"PrimaryLANGID",
			\"lANG_MACEDONIAN":"PrimaryLANGID",
			\"lANG_MALAY":"PrimaryLANGID",
			\"lANG_MALAYALAM":"PrimaryLANGID",
			\"lANG_MANIPURI":"PrimaryLANGID",
			\"lANG_MARATHI":"PrimaryLANGID",
			\"lANG_NEPALI":"PrimaryLANGID",
			\"lANG_NEUTRAL":"PrimaryLANGID",
			\"lANG_NORWEGIAN":"PrimaryLANGID",
			\"lANG_ORIYA":"PrimaryLANGID",
			\"lANG_POLISH":"PrimaryLANGID",
			\"lANG_PORTUGUESE":"PrimaryLANGID",
			\"lANG_PUNJABI":"PrimaryLANGID",
			\"lANG_ROMANIAN":"PrimaryLANGID",
			\"lANG_RUSSIAN":"PrimaryLANGID",
			\"lANG_SANSKRIT":"PrimaryLANGID",
			\"lANG_SERBIAN":"PrimaryLANGID",
			\"lANG_SINDHI":"PrimaryLANGID",
			\"lANG_SLOVAK":"PrimaryLANGID",
			\"lANG_SLOVENIAN":"PrimaryLANGID",
			\"lANG_SPANISH":"PrimaryLANGID",
			\"lANG_SWAHILI":"PrimaryLANGID",
			\"lANG_SWEDISH":"PrimaryLANGID",
			\"lANG_TAMIL":"PrimaryLANGID",
			\"lANG_TATAR":"PrimaryLANGID",
			\"lANG_TELUGU":"PrimaryLANGID",
			\"lANG_THAI":"PrimaryLANGID",
			\"lANG_TURKISH":"PrimaryLANGID",
			\"lANG_URDU":"PrimaryLANGID",
			\"lANG_UZBEK":"PrimaryLANGID",
			\"lANG_VIETNAMESE":"PrimaryLANGID",
			\"lCID_INSTALLED":"LocaleTestFlags",
			\"lCID_SUPPORTED":"LocaleTestFlags",
			\"lCMAP_BYTEREV":"LCMapFlags",
			\"lCMAP_FULLWIDTH":"LCMapFlags",
			\"lCMAP_HALFWIDTH":"LCMapFlags",
			\"lCMAP_HIRAGANA":"LCMapFlags",
			\"lCMAP_KATAKANA":"LCMapFlags",
			\"lCMAP_LINGUISTIC_CASING":"LCMapFlags",
			\"lCMAP_LOWERCASE":"LCMapFlags",
			\"lCMAP_SIMPLIFIED_CHINESE":"LCMapFlags",
			\"lCMAP_SORTKEY":"LCMapFlags",
			\"lCMAP_TRADITIONAL_CHINESE":"LCMapFlags",
			\"lCMAP_UPPERCASE":"LCMapFlags",
			\"lCMapString":"LCID -> LCMapFlags -> String -> Int -> IO String",
			\"lOCALE_ICALENDARTYPE":"LCTYPE",
			\"lOCALE_ICURRDIGITS":"LCTYPE",
			\"lOCALE_ICURRENCY":"LCTYPE",
			\"lOCALE_IDIGITS":"LCTYPE",
			\"lOCALE_IFIRSTDAYOFWEEK":"LCTYPE",
			\"lOCALE_IFIRSTWEEKOFYEAR":"LCTYPE",
			\"lOCALE_ILZERO":"LCTYPE",
			\"lOCALE_IMEASURE":"LCTYPE",
			\"lOCALE_INEGCURR":"LCTYPE",
			\"lOCALE_INEGNUMBER":"LCTYPE",
			\"lOCALE_ITIME":"LCTYPE",
			\"lOCALE_NEUTRAL":"LCID",
			\"lOCALE_S1159":"LCTYPE",
			\"lOCALE_S2359":"LCTYPE",
			\"lOCALE_SCURRENCY":"LCTYPE",
			\"lOCALE_SDATE":"LCTYPE",
			\"lOCALE_SDECIMAL":"LCTYPE",
			\"lOCALE_SGROUPING":"LCTYPE",
			\"lOCALE_SLIST":"LCTYPE",
			\"lOCALE_SLONGDATE":"LCTYPE",
			\"lOCALE_SMONDECIMALSEP":"LCTYPE",
			\"lOCALE_SMONGROUPING":"LCTYPE",
			\"lOCALE_SMONTHOUSANDSEP":"LCTYPE",
			\"lOCALE_SNEGATIVESIGN":"LCTYPE",
			\"lOCALE_SPOSITIVESIGN":"LCTYPE",
			\"lOCALE_SSHORTDATE":"LCTYPE",
			\"lOCALE_STHOUSAND":"LCTYPE",
			\"lOCALE_STIME":"LCTYPE",
			\"lOCALE_STIMEFORMAT":"LCTYPE",
			\"lOCALE_SYSTEM_DEFAULT":"LCID",
			\"lOCALE_USER_DEFAULT":"LCID",
			\"mAKELANGID":"PrimaryLANGID -> SubLANGID -> LANGID",
			\"mAKELCID":"LANGID -> SortID -> LCID",
			\"nORM_IGNORECASE":"LCMapFlags",
			\"nORM_IGNOREKANATYPE":"LCMapFlags",
			\"nORM_IGNORENONSPACE":"LCMapFlags",
			\"nORM_IGNORESYMBOLS":"LCMapFlags",
			\"nORM_IGNOREWIDTH":"LCMapFlags",
			\"pRIMARYLANGID":"LANGID -> PrimaryLANGID",
			\"sORTIDFROMLCID":"LCID -> SortID",
			\"sORT_CHINESE_BIG5":"SortID",
			\"sORT_CHINESE_UNICODE":"SortID",
			\"sORT_DEFAULT":"SortID",
			\"sORT_JAPANESE_UNICODE":"SortID",
			\"sORT_JAPANESE_XJIS":"SortID",
			\"sORT_KOREAN_KSC":"SortID",
			\"sORT_KOREAN_UNICODE":"SortID",
			\"sORT_STRINGSORT":"LCMapFlags",
			\"sUBLANGID":"LANGID -> SubLANGID",
			\"sUBLANG_ARABIC_ALGERIA":"SubLANGID",
			\"sUBLANG_ARABIC_BAHRAIN":"SubLANGID",
			\"sUBLANG_ARABIC_EGYPT":"SubLANGID",
			\"sUBLANG_ARABIC_IRAQ":"SubLANGID",
			\"sUBLANG_ARABIC_JORDAN":"SubLANGID",
			\"sUBLANG_ARABIC_KUWAIT":"SubLANGID",
			\"sUBLANG_ARABIC_LEBANON":"SubLANGID",
			\"sUBLANG_ARABIC_LIBYA":"SubLANGID",
			\"sUBLANG_ARABIC_MOROCCO":"SubLANGID",
			\"sUBLANG_ARABIC_OMAN":"SubLANGID",
			\"sUBLANG_ARABIC_QATAR":"SubLANGID",
			\"sUBLANG_ARABIC_SAUDI_ARABIA":"SubLANGID",
			\"sUBLANG_ARABIC_SYRIA":"SubLANGID",
			\"sUBLANG_ARABIC_TUNISIA":"SubLANGID",
			\"sUBLANG_ARABIC_UAE":"SubLANGID",
			\"sUBLANG_ARABIC_YEMEN":"SubLANGID",
			\"sUBLANG_AZERI_CYRILLIC":"SubLANGID",
			\"sUBLANG_AZERI_LATIN":"SubLANGID",
			\"sUBLANG_CHINESE_HONGKONG":"SubLANGID",
			\"sUBLANG_CHINESE_MACAU":"SubLANGID",
			\"sUBLANG_CHINESE_SIMPLIFIED":"SubLANGID",
			\"sUBLANG_CHINESE_SINGAPORE":"SubLANGID",
			\"sUBLANG_CHINESE_TRADITIONAL":"SubLANGID",
			\"sUBLANG_DEFAULT":"SubLANGID",
			\"sUBLANG_DUTCH":"SubLANGID",
			\"sUBLANG_DUTCH_BELGIAN":"SubLANGID",
			\"sUBLANG_ENGLISH_AUS":"SubLANGID",
			\"sUBLANG_ENGLISH_BELIZE":"SubLANGID",
			\"sUBLANG_ENGLISH_CAN":"SubLANGID",
			\"sUBLANG_ENGLISH_CARIBBEAN":"SubLANGID",
			\"sUBLANG_ENGLISH_EIRE":"SubLANGID",
			\"sUBLANG_ENGLISH_JAMAICA":"SubLANGID",
			\"sUBLANG_ENGLISH_NZ":"SubLANGID",
			\"sUBLANG_ENGLISH_PHILIPPINES":"SubLANGID",
			\"sUBLANG_ENGLISH_SOUTH_AFRICA":"SubLANGID",
			\"sUBLANG_ENGLISH_TRINIDAD":"SubLANGID",
			\"sUBLANG_ENGLISH_UK":"SubLANGID",
			\"sUBLANG_ENGLISH_US":"SubLANGID",
			\"sUBLANG_ENGLISH_ZIMBABWE":"SubLANGID",
			\"sUBLANG_FRENCH":"SubLANGID",
			\"sUBLANG_FRENCH_BELGIAN":"SubLANGID",
			\"sUBLANG_FRENCH_CANADIAN":"SubLANGID",
			\"sUBLANG_FRENCH_LUXEMBOURG":"SubLANGID",
			\"sUBLANG_FRENCH_MONACO":"SubLANGID",
			\"sUBLANG_FRENCH_SWISS":"SubLANGID",
			\"sUBLANG_GERMAN":"SubLANGID",
			\"sUBLANG_GERMAN_AUSTRIAN":"SubLANGID",
			\"sUBLANG_GERMAN_LIECHTENSTEIN":"SubLANGID",
			\"sUBLANG_GERMAN_LUXEMBOURG":"SubLANGID",
			\"sUBLANG_GERMAN_SWISS":"SubLANGID",
			\"sUBLANG_ITALIAN":"SubLANGID",
			\"sUBLANG_ITALIAN_SWISS":"SubLANGID",
			\"sUBLANG_KASHMIRI_INDIA":"SubLANGID",
			\"sUBLANG_KOREAN":"SubLANGID",
			\"sUBLANG_LITHUANIAN":"SubLANGID",
			\"sUBLANG_MALAY_BRUNEI_DARUSSALAM":"SubLANGID",
			\"sUBLANG_MALAY_MALAYSIA":"SubLANGID",
			\"sUBLANG_NEPALI_INDIA":"SubLANGID",
			\"sUBLANG_NEUTRAL":"SubLANGID",
			\"sUBLANG_NORWEGIAN_BOKMAL":"SubLANGID",
			\"sUBLANG_NORWEGIAN_NYNORSK":"SubLANGID",
			\"sUBLANG_PORTUGUESE":"SubLANGID",
			\"sUBLANG_PORTUGUESE_BRAZILIAN":"SubLANGID",
			\"sUBLANG_SERBIAN_CYRILLIC":"SubLANGID",
			\"sUBLANG_SERBIAN_LATIN":"SubLANGID",
			\"sUBLANG_SPANISH":"SubLANGID",
			\"sUBLANG_SPANISH_ARGENTINA":"SubLANGID",
			\"sUBLANG_SPANISH_BOLIVIA":"SubLANGID",
			\"sUBLANG_SPANISH_CHILE":"SubLANGID",
			\"sUBLANG_SPANISH_COLOMBIA":"SubLANGID",
			\"sUBLANG_SPANISH_COSTA_RICA":"SubLANGID",
			\"sUBLANG_SPANISH_DOMINICAN_REPUBLIC":"SubLANGID",
			\"sUBLANG_SPANISH_ECUADOR":"SubLANGID",
			\"sUBLANG_SPANISH_EL_SALVADOR":"SubLANGID",
			\"sUBLANG_SPANISH_GUATEMALA":"SubLANGID",
			\"sUBLANG_SPANISH_HONDURAS":"SubLANGID",
			\"sUBLANG_SPANISH_MEXICAN":"SubLANGID",
			\"sUBLANG_SPANISH_MODERN":"SubLANGID",
			\"sUBLANG_SPANISH_NICARAGUA":"SubLANGID",
			\"sUBLANG_SPANISH_PANAMA":"SubLANGID",
			\"sUBLANG_SPANISH_PARAGUAY":"SubLANGID",
			\"sUBLANG_SPANISH_PERU":"SubLANGID",
			\"sUBLANG_SPANISH_PUERTO_RICO":"SubLANGID",
			\"sUBLANG_SPANISH_URUGUAY":"SubLANGID",
			\"sUBLANG_SPANISH_VENEZUELA":"SubLANGID",
			\"sUBLANG_SWEDISH":"SubLANGID",
			\"sUBLANG_SWEDISH_FINLAND":"SubLANGID",
			\"sUBLANG_SYS_DEFAULT":"SubLANGID",
			\"sUBLANG_URDU_INDIA":"SubLANGID",
			\"sUBLANG_URDU_PAKISTAN":"SubLANGID",
			\"sUBLANG_UZBEK_CYRILLIC":"SubLANGID",
			\"sUBLANG_UZBEK_LATIN":"SubLANGID",
			\"setLocaleInfo":"LCID -> LCTYPE -> String -> IO ()",
			\"setThreadLocale":"LCID -> IO ()",
		\},
		\'System.Win32.Process':{
			\"iNFINITE":"DWORD",
			\"sleep":"DWORD -> IO ()",
		\},
		\'System.Win32.Registry':{
			\"c_RegCloseKey":"PKEY -> IO ErrCode",
			\"c_RegConnectRegistry":"LPCTSTR -> PKEY -> Ptr PKEY -> IO ErrCode",
			\"c_RegCreateKey":"PKEY -> LPCTSTR -> Ptr PKEY -> IO ErrCode",
			\"c_RegCreateKeyEx":"PKEY -> LPCTSTR -> DWORD -> LPCTSTR -> RegCreateOptions -> REGSAM -> LPSECURITY_ATTRIBUTES -> Ptr PKEY -> Ptr DWORD -> IO ErrCode",
			\"c_RegDeleteKey":"PKEY -> LPCTSTR -> IO ErrCode",
			\"c_RegDeleteValue":"PKEY -> LPCTSTR -> IO ErrCode",
			\"c_RegEnumKey":"PKEY -> DWORD -> LPTSTR -> DWORD -> IO ErrCode",
			\"c_RegEnumValue":"PKEY -> DWORD -> LPTSTR -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> LPBYTE -> Ptr DWORD -> IO ErrCode",
			\"c_RegFlushKey":"PKEY -> IO ErrCode",
			\"c_RegLoadKey":"PKEY -> LPCTSTR -> LPCTSTR -> IO ErrCode",
			\"c_RegNotifyChangeKeyValue":"PKEY -> Bool -> RegNotifyOptions -> HANDLE -> Bool -> IO ErrCode",
			\"c_RegOpenKey":"PKEY -> LPCTSTR -> Ptr PKEY -> IO ErrCode",
			\"c_RegOpenKeyEx":"PKEY -> LPCTSTR -> DWORD -> REGSAM -> Ptr PKEY -> IO ErrCode",
			\"c_RegQueryInfoKey":"PKEY -> LPTSTR -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr FILETIME -> IO ErrCode",
			\"c_RegQueryValue":"PKEY -> LPCTSTR -> LPTSTR -> Ptr LONG -> IO ErrCode",
			\"c_RegQueryValueEx":"PKEY -> LPCTSTR -> Ptr DWORD -> Ptr DWORD -> LPBYTE -> Ptr DWORD -> IO ErrCode",
			\"c_RegReplaceKey":"PKEY -> LPCTSTR -> LPCTSTR -> LPCTSTR -> IO ErrCode",
			\"c_RegRestoreKey":"PKEY -> LPCTSTR -> RegRestoreFlags -> IO ErrCode",
			\"c_RegSaveKey":"PKEY -> LPCTSTR -> LPSECURITY_ATTRIBUTES -> IO ErrCode",
			\"c_RegSetValue":"PKEY -> LPCTSTR -> DWORD -> LPCTSTR -> Int -> IO ErrCode",
			\"c_RegSetValueEx":"PKEY -> LPCTSTR -> DWORD -> RegValueType -> LPTSTR -> Int -> IO ErrCode",
			\"c_RegUnLoadKey":"PKEY -> LPCTSTR -> IO ErrCode",
			\"class_id":"RegInfoKey -> Int",
			\"class_string":"RegInfoKey -> String",
			\"eRROR_NO_MORE_ITEMS":"ErrCode",
			\"hKEY_CLASSES_ROOT":"HKEY",
			\"hKEY_CURRENT_CONFIG":"HKEY",
			\"hKEY_CURRENT_USER":"HKEY",
			\"hKEY_LOCAL_MACHINE":"HKEY",
			\"hKEY_USERS":"HKEY",
			\"kEY_ALL_ACCESS":"REGSAM",
			\"kEY_CREATE_LINK":"REGSAM",
			\"kEY_CREATE_SUB_KEY":"REGSAM",
			\"kEY_ENUMERATE_SUB_KEYS":"REGSAM",
			\"kEY_EXECUTE":"REGSAM",
			\"kEY_NOTIFY":"REGSAM",
			\"kEY_QUERY_VALUE":"REGSAM",
			\"kEY_READ":"REGSAM",
			\"kEY_SET_VALUE":"REGSAM",
			\"kEY_WRITE":"REGSAM",
			\"lastWrite_hi":"RegInfoKey -> Word32",
			\"lastWrite_lo":"RegInfoKey -> Word32",
			\"max_class_len":"RegInfoKey -> Word32",
			\"max_subkey_len":"RegInfoKey -> Word32",
			\"max_value_len":"RegInfoKey -> Word32",
			\"max_value_name_len":"RegInfoKey -> Word32",
			\"rEG_BINARY":"RegValueType",
			\"rEG_DWORD":"RegValueType",
			\"rEG_DWORD_BIG_ENDIAN":"RegValueType",
			\"rEG_DWORD_LITTLE_ENDIAN":"RegValueType",
			\"rEG_EXPAND_SZ":"RegValueType",
			\"rEG_LINK":"RegValueType",
			\"rEG_MULTI_SZ":"RegValueType",
			\"rEG_NONE":"RegValueType",
			\"rEG_NOTIFY_CHANGE_ATTRIBUTES":"RegNotifyOptions",
			\"rEG_NOTIFY_CHANGE_LAST_SET":"RegNotifyOptions",
			\"rEG_NOTIFY_CHANGE_NAME":"RegNotifyOptions",
			\"rEG_NOTIFY_CHANGE_SECURITY":"RegNotifyOptions",
			\"rEG_NO_LAZY_FLUSH":"RegRestoreFlags",
			\"rEG_OPTION_NON_VOLATILE":"RegCreateOptions",
			\"rEG_OPTION_VOLATILE":"RegCreateOptions",
			\"rEG_REFRESH_HIVE":"RegRestoreFlags",
			\"rEG_RESOURCE_LIST":"RegValueType",
			\"rEG_SZ":"RegValueType",
			\"rEG_WHOLE_HIVE_VOLATILE":"RegRestoreFlags",
			\"regCloseKey":"HKEY -> IO ()",
			\"regConnectRegistry":"Maybe String -> HKEY -> IO HKEY",
			\"regCreateKey":"HKEY -> String -> IO HKEY",
			\"regCreateKeyEx":"HKEY -> String -> String -> RegCreateOptions -> REGSAM -> Maybe LPSECURITY_ATTRIBUTES -> IO (HKEY, Bool)",
			\"regDeleteKey":"HKEY -> String -> IO ()",
			\"regDeleteValue":"HKEY -> String -> IO ()",
			\"regEnumKey":"HKEY -> DWORD -> LPTSTR -> DWORD -> IO (String, Int)",
			\"regEnumKeyVals":"HKEY -> IO [(String, String, RegValueType)]",
			\"regEnumKeys":"HKEY -> IO [String]",
			\"regEnumValue":"HKEY -> DWORD -> LPTSTR -> DWORD -> LPBYTE -> DWORD -> IO (RegValueType, String, Int)",
			\"regFlushKey":"HKEY -> IO ()",
			\"regLoadKey":"HKEY -> String -> String -> IO ()",
			\"regNotifyChangeKeyValue":"HKEY -> Bool -> RegNotifyOptions -> HANDLE -> Bool -> IO ()",
			\"regOpenKey":"HKEY -> String -> IO HKEY",
			\"regOpenKeyEx":"HKEY -> String -> REGSAM -> IO HKEY",
			\"regQueryInfoKey":"HKEY -> IO RegInfoKey",
			\"regQueryValue":"HKEY -> Maybe String -> IO String",
			\"regQueryValueEx":"HKEY -> String -> LPBYTE -> Int -> IO RegValueType",
			\"regQueryValueKey":"HKEY -> Maybe String -> IO String",
			\"regReplaceKey":"HKEY -> String -> String -> String -> IO ()",
			\"regRestoreKey":"HKEY -> String -> RegRestoreFlags -> IO ()",
			\"regSaveKey":"HKEY -> String -> Maybe LPSECURITY_ATTRIBUTES -> IO ()",
			\"regSetStringValue":"HKEY -> String -> String -> IO ()",
			\"regSetValue":"HKEY -> String -> String -> IO ()",
			\"regSetValueEx":"HKEY -> String -> RegValueType -> LPTSTR -> Int -> IO ()",
			\"regUnLoadKey":"HKEY -> String -> IO ()",
			\"sec_len":"RegInfoKey -> Int",
			\"subkeys":"RegInfoKey -> Word32",
			\"values":"RegInfoKey -> Word32",
		\},
		\'System.Win32.Types':{
			\"castFunPtrToLONG":"FunPtr a -> LONG",
			\"castPtrToUINT":"Ptr s -> UINT",
			\"castUINTToPtr":"UINT -> Ptr a",
			\"deleteObject_p":"FunPtr (HANDLE -> IO ())",
			\"errorWin":"String -> IO a",
			\"failIf":"(a -> Bool) -> String -> IO a -> IO a",
			\"failIfFalse_":"String -> IO Bool -> IO ()",
			\"failIfNull":"String -> IO (Ptr a) -> IO (Ptr a)",
			\"failIfZero":"Num a => String -> IO a -> IO a",
			\"failIf_":"(a -> Bool) -> String -> IO a -> IO ()",
			\"failUnlessSuccess":"String -> IO ErrCode -> IO ()",
			\"failUnlessSuccessOr":"ErrCode -> String -> IO ErrCode -> IO Bool",
			\"failWith":"String -> ErrCode -> IO a",
			\"getErrorMessage":"DWORD -> IO LPWSTR",
			\"getLastError":"IO ErrCode",
			\"hIWORD":"DWORD -> WORD",
			\"handleToWord":"HANDLE -> UINT",
			\"lOWORD":"DWORD -> WORD",
			\"localFree":"Ptr a -> IO (Ptr a)",
			\"maybeNum":"Num a => Maybe a -> a",
			\"maybePtr":"Maybe (Ptr a) -> Ptr a",
			\"newForeignHANDLE":"HANDLE -> IO ForeignHANDLE",
			\"newTString":"String -> IO LPCTSTR",
			\"nullFinalHANDLE":"ForeignPtr a",
			\"nullHANDLE":"HANDLE",
			\"numToMaybe":"Num a => a -> Maybe a",
			\"peekTString":"LPCTSTR -> IO String",
			\"peekTStringLen":"(LPCTSTR, Int) -> IO String",
			\"ptrToMaybe":"Ptr a -> Maybe (Ptr a)",
			\"withTString":"String -> (LPTSTR -> IO a) -> IO a",
			\"withTStringLen":"String -> ((LPTSTR, Int) -> IO a) -> IO a",
		\},
		\'Test.HUnit.Base':{
			\"assert":"Assertable t => t -> Assertion",
			\"assertBool":"String -> Bool -> Assertion",
			\"assertEqual":"(Eq a, Show a) => String -> a -> a -> Assertion",
			\"assertFailure":"String -> Assertion",
			\"assertString":"String -> Assertion",
			\"assertionPredicate":"AssertionPredicable t => t -> AssertionPredicate",
			\"cases":"Counts -> Int",
			\"counts":"State -> Counts",
			\"errors":"Counts -> Int",
			\"failures":"Counts -> Int",
			\"listAssert":"ListAssertable t => [t] -> Assertion",
			\"path":"State -> Path",
			\"performTest":"ReportStart us -> ReportProblem us -> ReportProblem us -> us -> Test -> IO (Counts, us)",
			\"test":"Testable t => t -> Test",
			\"testCaseCount":"Test -> Int",
			\"testCasePaths":"Test -> [Path]",
			\"tried":"Counts -> Int",
		\},
		\'Test.HUnit.Lang':{
			\"performTestCase":"Assertion -> IO (Maybe (Bool, String))",
		\},
		\'Test.HUnit.Terminal':{
			\"terminalAppearance":"String -> String",
		\},
		\'Test.HUnit.Text':{
			\"putTextToHandle":"Handle -> Bool -> PutText Int",
			\"putTextToShowS":"PutText ShowS",
			\"runTestTT":"Test -> IO Counts",
			\"runTestText":"PutText st -> Test -> IO (Counts, st)",
			\"showCounts":"Counts -> String",
			\"showPath":"Path -> String",
		\},
		\'Test.QuickCheck':{
			\"arbitrary":"Arbitrary a => Gen a",
			\"arguments":"Result -> [String]",
			\"check":"Testable a => Config -> a -> IO ()",
			\"choose":"Random a => (a, a) -> Gen a",
			\"classify":"Testable a => Bool -> String -> a -> Property",
			\"coarbitrary":"Arbitrary a => a -> Gen b -> Gen b",
			\"collect":"(Show a, Testable b) => a -> b -> Property",
			\"configEvery":"Config -> Int -> [String] -> String",
			\"configMaxFail":"Config -> Int",
			\"configMaxTest":"Config -> Int",
			\"configSize":"Config -> Int -> Int",
			\"defaultConfig":"Config",
			\"elements":"[a] -> Gen a",
			\"evaluate":"Testable a => a -> Gen Result",
			\"forAll":"(Show a, Testable b) => Gen a -> (a -> b) -> Property",
			\"four":"Monad m => m a -> m (a, a, a, a)",
			\"frequency":"[(Int, Gen a)] -> Gen a",
			\"generate":"Int -> StdGen -> Gen a -> a",
			\"label":"Testable a => String -> a -> Property",
			\"ok":"Result -> Maybe Bool",
			\"oneof":"[Gen a] -> Gen a",
			\"promote":"(a -> Gen b) -> Gen (a -> b)",
			\"property":"Testable a => a -> Property",
			\"quickCheck":"Testable a => a -> IO ()",
			\"rand":"Gen StdGen",
			\"resize":"Int -> Gen a -> Gen a",
			\"sized":"(Int -> Gen a) -> Gen a",
			\"stamp":"Result -> [String]",
			\"test":"Testable a => a -> IO ()",
			\"three":"Monad m => m a -> m (a, a, a)",
			\"trivial":"Testable a => Bool -> a -> Property",
			\"two":"Monad m => m a -> m (a, a)",
			\"variant":"Int -> Gen a -> Gen a",
			\"vector":"Arbitrary a => Int -> Gen [a]",
			\"verboseCheck":"Testable a => a -> IO ()",
		\},
		\'Test.QuickCheck.Batch':{
			\"bottom":"a",
			\"debug_tests":"TestOptions -> Bool",
			\"defOpt":"TestOptions",
			\"isBottom":"a -> Bool",
			\"length_of_tests":"TestOptions -> Int",
			\"no_of_tests":"TestOptions -> Int",
			\"run":"Testable a => a -> TestOptions -> IO TestResult",
			\"runTests":"String -> TestOptions -> [TestOptions -> IO TestResult] -> IO ()",
		\},
		\'Test.QuickCheck.Poly':{
		\},
		\'Test.QuickCheck.Utils':{
			\"isAssociative":"(Arbitrary a, Show a, Eq a) => (a -> a -> a) -> Property",
			\"isAssociativeBy":"(Show a, Testable prop) => (a -> a -> prop) -> Gen a -> (a -> a -> a) -> Property",
			\"isCommutable":"(Arbitrary a, Show a, Eq b) => (a -> a -> b) -> Property",
			\"isCommutableBy":"(Show a, Testable prop) => (b -> b -> prop) -> Gen a -> (a -> a -> b) -> Property",
			\"isTotalOrder":"(Arbitrary a, Show a, Ord a) => a -> a -> Property",
		\},
		\'Text.Html':{
			\"above":"(HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable",
			\"aboves":"HTMLTABLE ht => [ht] -> HtmlTable",
			\"action":"String -> HtmlAttr",
			\"address":"Html -> Html",
			\"afile":"String -> Html",
			\"align":"String -> HtmlAttr",
			\"alink":"String -> HtmlAttr",
			\"alt":"String -> HtmlAttr",
			\"altcode":"String -> HtmlAttr",
			\"anchor":"Html -> Html",
			\"applet":"Html -> Html",
			\"aqua":"String",
			\"archive":"String -> HtmlAttr",
			\"area":"Html",
			\"background":"String -> HtmlAttr",
			\"base":"String -> HtmlAttr",
			\"basefont":"Html",
			\"beside":"(HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable",
			\"besides":"HTMLTABLE ht => [ht] -> HtmlTable",
			\"bgcolor":"String -> HtmlAttr",
			\"big":"Html -> Html",
			\"black":"String",
			\"blockquote":"Html -> Html",
			\"blue":"String",
			\"body":"Html -> Html",
			\"bold":"Html -> Html",
			\"border":"Int -> HtmlAttr",
			\"bordercolor":"String -> HtmlAttr",
			\"br":"Html",
			\"bullet":"Html",
			\"caption":"Html -> Html",
			\"cell":"HTMLTABLE ht => ht -> HtmlTable",
			\"cellpadding":"Int -> HtmlAttr",
			\"cellspacing":"Int -> HtmlAttr",
			\"center":"Html -> Html",
			\"checkbox":"String -> String -> Html",
			\"checked":"HtmlAttr",
			\"cite":"Html -> Html",
			\"clear":"String -> HtmlAttr",
			\"clickmap":"String -> Html",
			\"code":"String -> HtmlAttr",
			\"codebase":"String -> HtmlAttr",
			\"color":"String -> HtmlAttr",
			\"cols":"String -> HtmlAttr",
			\"colspan":"Int -> HtmlAttr",
			\"compact":"HtmlAttr",
			\"concatHtml":"HTML a => [a] -> Html",
			\"content":"String -> HtmlAttr",
			\"coords":"String -> HtmlAttr",
			\"copyright":"Html",
			\"ddef":"Html -> Html",
			\"debugHtml":"HTML a => a -> Html",
			\"defList":"(HTML a, HTML b) => [(a, b)] -> Html",
			\"define":"Html -> Html",
			\"dlist":"Html -> Html",
			\"dterm":"Html -> Html",
			\"emphasize":"Html -> Html",
			\"emptyAttr":"String -> HtmlAttr",
			\"enctype":"String -> HtmlAttr",
			\"face":"String -> HtmlAttr",
			\"fieldset":"Html -> Html",
			\"font":"Html -> Html",
			\"form":"Html -> Html",
			\"frame":"Html -> Html",
			\"frameborder":"Int -> HtmlAttr",
			\"frameset":"Html -> Html",
			\"fuchsia":"String",
			\"getHtmlElements":"Html -> [HtmlElement]",
			\"gray":"String",
			\"green":"String",
			\"gui":"String -> Html -> Html",
			\"h1":"Html -> Html",
			\"h2":"Html -> Html",
			\"h3":"Html -> Html",
			\"h4":"Html -> Html",
			\"h5":"Html -> Html",
			\"h6":"Html -> Html",
			\"header":"Html -> Html",
			\"height":"Int -> HtmlAttr",
			\"hidden":"String -> String -> Html",
			\"hotLinkAttributes":"HotLink -> [HtmlAttr]",
			\"hotLinkContents":"HotLink -> [Html]",
			\"hotLinkURL":"HotLink -> URL",
			\"hotlink":"URL -> [Html] -> HotLink",
			\"hr":"Html",
			\"href":"String -> HtmlAttr",
			\"hspace":"Int -> HtmlAttr",
			\"httpequiv":"String -> HtmlAttr",
			\"identifier":"String -> HtmlAttr",
			\"image":"Html",
			\"input":"Html",
			\"intAttr":"String -> Int -> HtmlAttr",
			\"ismap":"HtmlAttr",
			\"itag":"String -> Html",
			\"italics":"Html -> Html",
			\"keyboard":"Html -> Html",
			\"lang":"String -> HtmlAttr",
			\"legend":"Html -> Html",
			\"li":"Html -> Html",
			\"lime":"String",
			\"lineToHtml":"String -> Html",
			\"linesToHtml":"[String] -> Html",
			\"link":"String -> HtmlAttr",
			\"marginheight":"Int -> HtmlAttr",
			\"marginwidth":"Int -> HtmlAttr",
			\"markupAttrs":"HtmlElement -> [HtmlAttr]",
			\"markupContent":"HtmlElement -> Html",
			\"markupTag":"HtmlElement -> String",
			\"maroon":"String",
			\"maxlength":"Int -> HtmlAttr",
			\"menu":"String -> [Html] -> Html",
			\"meta":"Html",
			\"method":"String -> HtmlAttr",
			\"mkHtmlTable":"BlockTable (Int -> Int -> Html) -> HtmlTable",
			\"multiple":"HtmlAttr",
			\"name":"String -> HtmlAttr",
			\"navy":"String",
			\"noHtml":"Html",
			\"noframes":"Html -> Html",
			\"nohref":"HtmlAttr",
			\"noresize":"HtmlAttr",
			\"noshade":"HtmlAttr",
			\"nowrap":"HtmlAttr",
			\"olist":"Html -> Html",
			\"olive":"String",
			\"option":"Html -> Html",
			\"ordList":"HTML a => [a] -> Html",
			\"p":"Html -> Html",
			\"paragraph":"Html -> Html",
			\"param":"Html",
			\"password":"String -> Html",
			\"pre":"Html -> Html",
			\"prettyHtml":"HTML html => html -> String",
			\"prettyHtml'":"HtmlElement -> [String]",
			\"primHtml":"String -> Html",
			\"primHtmlChar":"String -> Html",
			\"purple":"String",
			\"radio":"String -> String -> Html",
			\"red":"String",
			\"rel":"String -> HtmlAttr",
			\"renderHtml":"HTML html => html -> String",
			\"renderHtml'":"Int -> HtmlElement -> ShowS",
			\"renderTable":"BlockTable (Int -> Int -> Html) -> Html",
			\"renderTag":"Bool -> String -> [HtmlAttr] -> Int -> ShowS",
			\"reset":"String -> String -> Html",
			\"rev":"String -> HtmlAttr",
			\"rows":"String -> HtmlAttr",
			\"rowspan":"Int -> HtmlAttr",
			\"rules":"String -> HtmlAttr",
			\"sample":"Html -> Html",
			\"scrolling":"String -> HtmlAttr",
			\"select":"Html -> Html",
			\"selected":"HtmlAttr",
			\"shape":"String -> HtmlAttr",
			\"silver":"String",
			\"simpleTable":"[HtmlAttr] -> [HtmlAttr] -> [[Html]] -> Html",
			\"size":"String -> HtmlAttr",
			\"small":"Html -> Html",
			\"spaceHtml":"Html",
			\"src":"String -> HtmlAttr",
			\"start":"Int -> HtmlAttr",
			\"strAttr":"String -> String -> HtmlAttr",
			\"stringToHtml":"String -> Html",
			\"stringToHtmlString":"String -> String",
			\"strong":"Html -> Html",
			\"style":"Html -> Html",
			\"sub":"Html -> Html",
			\"submit":"String -> String -> Html",
			\"sup":"Html -> Html",
			\"table":"Html -> Html",
			\"tag":"String -> Html -> Html",
			\"target":"String -> HtmlAttr",
			\"td":"Html -> Html",
			\"teal":"String",
			\"text":"String -> HtmlAttr",
			\"textarea":"Html -> Html",
			\"textfield":"String -> Html",
			\"th":"Html -> Html",
			\"thebase":"Html",
			\"theclass":"String -> HtmlAttr",
			\"thecode":"Html -> Html",
			\"thediv":"Html -> Html",
			\"thehtml":"Html -> Html",
			\"thelink":"Html -> Html",
			\"themap":"Html -> Html",
			\"thespan":"Html -> Html",
			\"thestyle":"String -> HtmlAttr",
			\"thetitle":"Html -> Html",
			\"thetype":"String -> HtmlAttr",
			\"title":"String -> HtmlAttr",
			\"toHtml":"HTML a => a -> Html",
			\"toHtmlFromList":"HTML a => [a] -> Html",
			\"tr":"Html -> Html",
			\"treeHtml":"[String] -> HtmlTree -> Html",
			\"tt":"Html -> Html",
			\"ulist":"Html -> Html",
			\"underline":"Html -> Html",
			\"unordList":"HTML a => [a] -> Html",
			\"usemap":"String -> HtmlAttr",
			\"validHtmlAttrs":"[String]",
			\"validHtmlITags":"[String]",
			\"validHtmlTags":"[String]",
			\"valign":"String -> HtmlAttr",
			\"value":"String -> HtmlAttr",
			\"variable":"Html -> Html",
			\"version":"String -> HtmlAttr",
			\"vlink":"String -> HtmlAttr",
			\"vspace":"Int -> HtmlAttr",
			\"white":"String",
			\"widget":"String -> String -> [HtmlAttr] -> Html",
			\"width":"String -> HtmlAttr",
			\"yellow":"String",
		\},
		\'Text.Html.BlockTable':{
			\"above":"BlockTable a -> BlockTable a -> BlockTable a",
			\"beside":"BlockTable a -> BlockTable a -> BlockTable a",
			\"getMatrix":"BlockTable a -> [[(a, (Int, Int))]]",
			\"showTable":"Show a => BlockTable a -> String",
			\"showsTable":"Show a => BlockTable a -> ShowS",
			\"single":"a -> BlockTable a",
		\},
		\'Text.ParserCombinators.Parsec':{
			\"errorPos":"ParseError -> SourcePos",
			\"incSourceColumn":"SourcePos -> Column -> SourcePos",
			\"incSourceLine":"SourcePos -> Line -> SourcePos",
			\"setSourceColumn":"SourcePos -> Column -> SourcePos",
			\"setSourceLine":"SourcePos -> Line -> SourcePos",
			\"setSourceName":"SourcePos -> SourceName -> SourcePos",
			\"sourceColumn":"SourcePos -> Column",
			\"sourceLine":"SourcePos -> Line",
			\"sourceName":"SourcePos -> SourceName",
		\},
		\'Text.ParserCombinators.Parsec.Char':{
			\"alphaNum":"CharParser st Char",
			\"anyChar":"CharParser st Char",
			\"char":"Char -> CharParser st Char",
			\"digit":"CharParser st Char",
			\"hexDigit":"CharParser st Char",
			\"letter":"CharParser st Char",
			\"lower":"CharParser st Char",
			\"newline":"CharParser st Char",
			\"noneOf":"[Char] -> CharParser st Char",
			\"octDigit":"CharParser st Char",
			\"oneOf":"[Char] -> CharParser st Char",
			\"satisfy":"(Char -> Bool) -> CharParser st Char",
			\"space":"CharParser st Char",
			\"spaces":"CharParser st ()",
			\"string":"String -> CharParser st String",
			\"tab":"CharParser st Char",
			\"upper":"CharParser st Char",
		\},
		\'Text.ParserCombinators.Parsec.Combinator':{
			\"anyToken":"Show tok => GenParser tok st tok",
			\"between":"GenParser tok st open -> GenParser tok st close -> GenParser tok st a -> GenParser tok st a",
			\"chainl":"GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a",
			\"chainl1":"GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a",
			\"chainr":"GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a",
			\"chainr1":"GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a",
			\"choice":"[GenParser tok st a] -> GenParser tok st a",
			\"count":"Int -> GenParser tok st a -> GenParser tok st [a]",
			\"endBy":"GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]",
			\"endBy1":"GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]",
			\"eof":"Show tok => GenParser tok st ()",
			\"lookAhead":"GenParser tok st a -> GenParser tok st a",
			\"many1":"GenParser tok st a -> GenParser tok st [a]",
			\"manyTill":"GenParser tok st a -> GenParser tok st end -> GenParser tok st [a]",
			\"notFollowedBy":"Show tok => GenParser tok st tok -> GenParser tok st ()",
			\"option":"a -> GenParser tok st a -> GenParser tok st a",
			\"optional":"GenParser tok st a -> GenParser tok st ()",
			\"sepBy":"GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]",
			\"sepBy1":"GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]",
			\"sepEndBy":"GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]",
			\"sepEndBy1":"GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]",
			\"skipMany1":"GenParser tok st a -> GenParser tok st ()",
		\},
		\'Text.ParserCombinators.Parsec.Error':{
			\"addErrorMessage":"Message -> ParseError -> ParseError",
			\"errorIsUnknown":"ParseError -> Bool",
			\"errorMessages":"ParseError -> [Message]",
			\"mergeError":"ParseError -> ParseError -> ParseError",
			\"messageCompare":"Message -> Message -> Ordering",
			\"messageEq":"Message -> Message -> Bool",
			\"messageString":"Message -> String",
			\"newErrorMessage":"Message -> SourcePos -> ParseError",
			\"newErrorUnknown":"SourcePos -> ParseError",
			\"setErrorMessage":"Message -> ParseError -> ParseError",
			\"setErrorPos":"SourcePos -> ParseError -> ParseError",
			\"showErrorMessages":"String -> String -> String -> String -> String -> [Message] -> String",
		\},
		\'Text.ParserCombinators.Parsec.Expr':{
			\"buildExpressionParser":"OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a",
		\},
		\'Text.ParserCombinators.Parsec.Language':{
			\"caseSensitive":"LanguageDef st -> Bool",
			\"commentEnd":"LanguageDef st -> String",
			\"commentLine":"LanguageDef st -> String",
			\"commentStart":"LanguageDef st -> String",
			\"emptyDef":"LanguageDef st",
			\"haskell":"TokenParser st",
			\"haskellDef":"LanguageDef st",
			\"haskellStyle":"LanguageDef st",
			\"identLetter":"LanguageDef st -> CharParser st Char",
			\"identStart":"LanguageDef st -> CharParser st Char",
			\"javaStyle":"LanguageDef st",
			\"mondrian":"TokenParser st",
			\"mondrianDef":"LanguageDef st",
			\"nestedComments":"LanguageDef st -> Bool",
			\"opLetter":"LanguageDef st -> CharParser st Char",
			\"opStart":"LanguageDef st -> CharParser st Char",
			\"reservedNames":"LanguageDef st -> [String]",
			\"reservedOpNames":"LanguageDef st -> [String]",
		\},
		\'Text.ParserCombinators.Parsec.Perm':{
			\"permute":"PermParser tok st a -> GenParser tok st a",
		\},
		\'Text.ParserCombinators.Parsec.Pos':{
			\"initialPos":"SourceName -> SourcePos",
			\"newPos":"SourceName -> Line -> Column -> SourcePos",
			\"updatePosChar":"SourcePos -> Char -> SourcePos",
			\"updatePosString":"SourcePos -> String -> SourcePos",
		\},
		\'Text.ParserCombinators.Parsec.Prim':{
			\"getInput":"GenParser tok st [tok]",
			\"getParserState":"GenParser tok st (State tok st)",
			\"getPosition":"GenParser tok st SourcePos",
			\"getState":"GenParser tok st st",
			\"label":"GenParser tok st a -> String -> GenParser tok st a",
			\"labels":"GenParser tok st a -> [String] -> GenParser tok st a",
			\"many":"GenParser tok st a -> GenParser tok st [a]",
			\"parse":"GenParser tok () a -> SourceName -> [tok] -> Either ParseError a",
			\"parseFromFile":"Parser a -> SourceName -> IO (Either ParseError a)",
			\"parseTest":"Show a => GenParser tok () a -> [tok] -> IO ()",
			\"pzero":"GenParser tok st a",
			\"runParser":"GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a",
			\"setInput":"[tok] -> GenParser tok st ()",
			\"setParserState":"State tok st -> GenParser tok st (State tok st)",
			\"setPosition":"SourcePos -> GenParser tok st ()",
			\"setState":"st -> GenParser tok st ()",
			\"skipMany":"GenParser tok st a -> GenParser tok st ()",
			\"stateInput":"State tok st -> [tok]",
			\"statePos":"State tok st -> !SourcePos",
			\"stateUser":"State tok st -> !st",
			\"token":"(tok -> String) -> (tok -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a",
			\"tokenPrim":"(tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a",
			\"tokenPrimEx":"(tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> Maybe (SourcePos -> tok -> [tok] -> st -> st) -> (tok -> Maybe a) -> GenParser tok st a",
			\"tokens":"Eq tok => ([tok] -> String) -> (SourcePos -> [tok] -> SourcePos) -> [tok] -> GenParser tok st [tok]",
			\"try":"GenParser tok st a -> GenParser tok st a",
			\"unexpected":"String -> GenParser tok st a",
			\"updateState":"(st -> st) -> GenParser tok st ()",
		\},
		\'Text.ParserCombinators.Parsec.Token':{
			\"angles":"TokenParser st -> CharParser st a -> CharParser st a",
			\"braces":"TokenParser st -> CharParser st a -> CharParser st a",
			\"brackets":"TokenParser st -> CharParser st a -> CharParser st a",
			\"charLiteral":"TokenParser st -> CharParser st Char",
			\"colon":"TokenParser st -> CharParser st String",
			\"comma":"TokenParser st -> CharParser st String",
			\"commaSep":"TokenParser st -> CharParser st a -> CharParser st [a]",
			\"commaSep1":"TokenParser st -> CharParser st a -> CharParser st [a]",
			\"decimal":"TokenParser st -> CharParser st Integer",
			\"dot":"TokenParser st -> CharParser st String",
			\"float":"TokenParser st -> CharParser st Double",
			\"hexadecimal":"TokenParser st -> CharParser st Integer",
			\"identifier":"TokenParser st -> CharParser st String",
			\"integer":"TokenParser st -> CharParser st Integer",
			\"lexeme":"TokenParser st -> CharParser st a -> CharParser st a",
			\"makeTokenParser":"LanguageDef st -> TokenParser st",
			\"natural":"TokenParser st -> CharParser st Integer",
			\"naturalOrFloat":"TokenParser st -> (CharParser st (Either Integer Double))",
			\"octal":"TokenParser st -> CharParser st Integer",
			\"operator":"TokenParser st -> CharParser st String",
			\"parens":"TokenParser st -> CharParser st a -> CharParser st a",
			\"reserved":"TokenParser st -> (String -> CharParser st ())",
			\"reservedOp":"TokenParser st -> (String -> CharParser st ())",
			\"semi":"TokenParser st -> CharParser st String",
			\"semiSep":"TokenParser st -> CharParser st a -> CharParser st [a]",
			\"semiSep1":"TokenParser st -> CharParser st a -> CharParser st [a]",
			\"squares":"TokenParser st -> CharParser st a -> CharParser st a",
			\"stringLiteral":"TokenParser st -> CharParser st String",
			\"symbol":"TokenParser st -> String -> CharParser st String",
			\"whiteSpace":"TokenParser st -> (CharParser st ())",
		\},
		\'Text.ParserCombinators.ReadP':{
			\"between":"ReadP open -> ReadP close -> ReadP a -> ReadP a",
			\"chainl":"ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a",
			\"chainl1":"ReadP a -> ReadP (a -> a -> a) -> ReadP a",
			\"chainr":"ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a",
			\"chainr1":"ReadP a -> ReadP (a -> a -> a) -> ReadP a",
			\"char":"Char -> ReadP Char",
			\"choice":"[ReadP a] -> ReadP a",
			\"count":"Int -> ReadP a -> ReadP [a]",
			\"endBy":"ReadP a -> ReadP sep -> ReadP [a]",
			\"endBy1":"ReadP a -> ReadP sep -> ReadP [a]",
			\"gather":"ReadP a -> ReadP (String, a)",
			\"get":"ReadP Char",
			\"look":"ReadP String",
			\"many":"ReadP a -> ReadP [a]",
			\"many1":"ReadP a -> ReadP [a]",
			\"manyTill":"ReadP a -> ReadP end -> ReadP [a]",
			\"munch":"(Char -> Bool) -> ReadP String",
			\"munch1":"(Char -> Bool) -> ReadP String",
			\"option":"a -> ReadP a -> ReadP a",
			\"optional":"ReadP a -> ReadP ()",
			\"pfail":"ReadP a",
			\"readP_to_S":"ReadP a -> ReadS a",
			\"readS_to_P":"ReadS a -> ReadP a",
			\"satisfy":"(Char -> Bool) -> ReadP Char",
			\"sepBy":"ReadP a -> ReadP sep -> ReadP [a]",
			\"sepBy1":"ReadP a -> ReadP sep -> ReadP [a]",
			\"skipMany":"ReadP a -> ReadP ()",
			\"skipMany1":"ReadP a -> ReadP ()",
			\"skipSpaces":"ReadP ()",
			\"string":"String -> ReadP String",
		\},
		\'Text.ParserCombinators.ReadPrec':{
			\"choice":"[ReadPrec a] -> ReadPrec a",
			\"get":"ReadPrec Char",
			\"lift":"ReadP a -> ReadPrec a",
			\"look":"ReadPrec String",
			\"minPrec":"Prec",
			\"pfail":"ReadPrec a",
			\"prec":"Prec -> ReadPrec a -> ReadPrec a",
			\"readP_to_Prec":"(Int -> ReadP a) -> ReadPrec a",
			\"readPrec_to_P":"ReadPrec a -> Int -> ReadP a",
			\"readPrec_to_S":"ReadPrec a -> Int -> ReadS a",
			\"readS_to_Prec":"(Int -> ReadS a) -> ReadPrec a",
			\"reset":"ReadPrec a -> ReadPrec a",
			\"step":"ReadPrec a -> ReadPrec a",
		\},
		\'Text.PrettyPrint.HughesPJ':{
			\"braces":"Doc -> Doc",
			\"brackets":"Doc -> Doc",
			\"cat":"[Doc] -> Doc",
			\"char":"Char -> Doc",
			\"colon":"Doc",
			\"comma":"Doc",
			\"double":"Double -> Doc",
			\"doubleQuotes":"Doc -> Doc",
			\"empty":"Doc",
			\"equals":"Doc",
			\"fcat":"[Doc] -> Doc",
			\"float":"Float -> Doc",
			\"fsep":"[Doc] -> Doc",
			\"fullRender":"Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a",
			\"hang":"Doc -> Int -> Doc -> Doc",
			\"hcat":"[Doc] -> Doc",
			\"hsep":"[Doc] -> Doc",
			\"int":"Int -> Doc",
			\"integer":"Integer -> Doc",
			\"isEmpty":"Doc -> Bool",
			\"lbrace":"Doc",
			\"lbrack":"Doc",
			\"lineLength":"Style -> Int",
			\"lparen":"Doc",
			\"mode":"Style -> Mode",
			\"nest":"Int -> Doc -> Doc",
			\"parens":"Doc -> Doc",
			\"ptext":"String -> Doc",
			\"punctuate":"Doc -> [Doc] -> [Doc]",
			\"quotes":"Doc -> Doc",
			\"rational":"Rational -> Doc",
			\"rbrace":"Doc",
			\"rbrack":"Doc",
			\"render":"Doc -> String",
			\"renderStyle":"Style -> Doc -> String",
			\"ribbonsPerLine":"Style -> Float",
			\"rparen":"Doc",
			\"semi":"Doc",
			\"sep":"[Doc] -> Doc",
			\"space":"Doc",
			\"style":"Style",
			\"text":"String -> Doc",
			\"vcat":"[Doc] -> Doc",
		\},
		\'Text.Printf':{
			\"hPrintf":"HPrintfType r => Handle -> String -> r",
			\"printf":"PrintfType r => String -> r",
		\},
		\'Text.Read':{
			\"lexP":"ReadPrec Lexeme",
			\"readListDefault":"Read a => ReadS [a]",
			\"readListPrec":"Read a => ReadPrec [a]",
			\"readListPrecDefault":"Read a => ReadPrec [a]",
			\"readPrec":"Read a => ReadPrec a",
		\},
		\'Text.Read.Lex':{
			\"hsLex":"ReadP String",
			\"lex":"ReadP Lexeme",
			\"lexChar":"ReadP Char",
			\"readDecP":"Num a => ReadP a",
			\"readHexP":"Num a => ReadP a",
			\"readIntP":"Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a",
			\"readOctP":"Num a => ReadP a",
		\},
		\'Text.Regex':{
			\"matchRegex":"Regex -> String -> Maybe [String]",
			\"matchRegexAll":"Regex -> String -> Maybe (String, String, String, [String])",
			\"mkRegex":"String -> Regex",
			\"mkRegexWithOpts":"String -> Bool -> Bool -> Regex",
			\"splitRegex":"Regex -> String -> [String]",
			\"subRegex":"Regex -> String -> String -> String",
		\},
		\'Text.Regex.Posix':{
			\"regExtended":"Int",
			\"regIgnoreCase":"Int",
			\"regNewline":"Int",
			\"regcomp":"String -> Int -> IO Regex",
			\"regexec":"Regex -> String -> IO (Maybe (String, String, String, [String]))",
		\},
		\'Text.Show':{
			\"showListWith":"(a -> ShowS) -> [a] -> ShowS",
		\},
		\'Time':{
			\"addToClockTime":"TimeDiff -> ClockTime -> ClockTime",
			\"calendarTimeToString":"CalendarTime -> String",
			\"diffClockTimes":"ClockTime -> ClockTime -> TimeDiff",
			\"formatCalendarTime":"TimeLocale -> String -> CalendarTime -> String",
			\"getClockTime":"IO ClockTime",
			\"toCalendarTime":"ClockTime -> IO CalendarTime",
			\"toClockTime":"CalendarTime -> ClockTime",
			\"toUTCTime":"ClockTime -> CalendarTime",
		\},
	\} "}}}
	let g:haskell_lib_types = {
		\'Prelude':{
			\'Bool':'',
			\'Char':'',
			\'Either':'',
			\'Float':'',
			\'Maybe':'',
			\'Int':'',
			\'Integer':'',
			\'Ordering':'',
			\'Rational':'',
			\'String':'',
		\},
	\}
endfunction
" vim: noet sw=8 ts=8 ai sts=0:
